# Generated from EnglishLangParser.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,72,467,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,1,0,1,0,4,0,75,8,0,11,0,12,0,76,1,0,1,0,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,92,8,1,1,2,1,2,1,
        2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,103,8,2,1,3,3,3,106,8,3,1,3,1,3,1,
        3,1,3,1,3,1,4,3,4,114,8,4,1,4,1,4,3,4,118,8,4,1,5,1,5,3,5,122,8,
        5,1,6,1,6,1,6,1,6,5,6,128,8,6,10,6,12,6,131,9,6,1,6,1,6,1,7,1,7,
        1,7,5,7,138,8,7,10,7,12,7,141,9,7,1,8,1,8,1,8,3,8,146,8,8,1,9,1,
        9,1,9,5,9,151,8,9,10,9,12,9,154,9,9,1,10,1,10,1,10,1,10,1,10,1,10,
        1,10,1,10,1,10,1,10,1,10,1,10,1,10,3,10,169,8,10,1,11,1,11,1,12,
        1,12,1,12,1,12,3,12,177,8,12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,
        5,13,186,8,13,10,13,12,13,189,9,13,1,14,1,14,1,14,1,15,1,15,1,15,
        1,16,3,16,198,8,16,1,16,1,16,1,16,3,16,203,8,16,1,16,1,16,1,17,1,
        17,1,17,5,17,210,8,17,10,17,12,17,213,9,17,1,18,1,18,1,18,1,18,1,
        18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,3,18,227,8,18,1,19,1,19,1,
        19,1,19,1,19,1,19,3,19,235,8,19,1,19,1,19,1,19,1,19,1,19,1,19,3,
        19,243,8,19,5,19,245,8,19,10,19,12,19,248,9,19,1,19,1,19,1,19,3,
        19,253,8,19,3,19,255,8,19,1,20,1,20,1,20,1,20,1,20,1,20,4,20,263,
        8,20,11,20,12,20,264,1,20,1,20,1,20,3,20,270,8,20,1,20,1,20,1,20,
        1,20,1,20,1,20,4,20,278,8,20,11,20,12,20,279,1,20,1,20,1,20,3,20,
        285,8,20,5,20,287,8,20,10,20,12,20,290,9,20,1,20,1,20,1,20,4,20,
        295,8,20,11,20,12,20,296,1,20,1,20,1,20,3,20,302,8,20,3,20,304,8,
        20,1,21,1,21,3,21,308,8,21,1,22,1,22,1,22,3,22,313,8,22,1,22,1,22,
        1,22,1,22,1,22,1,22,1,22,1,23,1,23,3,23,324,8,23,1,24,1,24,1,24,
        3,24,329,8,24,1,25,1,25,4,25,333,8,25,11,25,12,25,334,1,25,1,25,
        1,25,3,25,340,8,25,1,26,1,26,1,26,1,26,1,26,1,26,4,26,348,8,26,11,
        26,12,26,349,1,26,1,26,1,26,3,26,355,8,26,1,27,1,27,1,27,1,27,5,
        27,361,8,27,10,27,12,27,364,9,27,1,28,1,28,4,28,368,8,28,11,28,12,
        28,369,1,28,1,28,1,29,1,29,1,29,1,29,1,29,1,29,5,29,380,8,29,10,
        29,12,29,383,9,29,1,30,1,30,1,30,1,30,1,30,1,30,5,30,391,8,30,10,
        30,12,30,394,9,30,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,3,
        31,405,8,31,1,32,1,32,1,32,3,32,410,8,32,1,33,1,33,1,33,1,33,1,33,
        3,33,417,8,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,425,8,33,1,33,1,
        33,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,
        34,1,34,3,34,443,8,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,3,34,452,
        8,34,1,34,3,34,455,8,34,1,34,1,34,1,34,5,34,460,8,34,10,34,12,34,
        463,9,34,1,35,1,35,1,35,0,3,58,60,68,36,0,2,4,6,8,10,12,14,16,18,
        20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,
        64,66,68,70,0,9,2,0,56,56,70,70,1,0,57,61,1,0,66,69,1,0,24,25,1,
        0,26,28,1,0,36,37,2,0,29,29,40,40,1,0,41,42,2,0,29,33,40,40,518,
        0,72,1,0,0,0,2,91,1,0,0,0,4,102,1,0,0,0,6,105,1,0,0,0,8,113,1,0,
        0,0,10,121,1,0,0,0,12,123,1,0,0,0,14,134,1,0,0,0,16,145,1,0,0,0,
        18,147,1,0,0,0,20,168,1,0,0,0,22,170,1,0,0,0,24,172,1,0,0,0,26,182,
        1,0,0,0,28,190,1,0,0,0,30,193,1,0,0,0,32,197,1,0,0,0,34,206,1,0,
        0,0,36,226,1,0,0,0,38,228,1,0,0,0,40,256,1,0,0,0,42,307,1,0,0,0,
        44,309,1,0,0,0,46,323,1,0,0,0,48,328,1,0,0,0,50,339,1,0,0,0,52,341,
        1,0,0,0,54,356,1,0,0,0,56,365,1,0,0,0,58,373,1,0,0,0,60,384,1,0,
        0,0,62,404,1,0,0,0,64,409,1,0,0,0,66,411,1,0,0,0,68,454,1,0,0,0,
        70,464,1,0,0,0,72,74,5,1,0,0,73,75,3,2,1,0,74,73,1,0,0,0,75,76,1,
        0,0,0,76,74,1,0,0,0,76,77,1,0,0,0,77,78,1,0,0,0,78,79,5,2,0,0,79,
        1,1,0,0,0,80,92,3,6,3,0,81,92,3,66,33,0,82,92,3,24,12,0,83,92,3,
        32,16,0,84,92,3,30,15,0,85,92,3,54,27,0,86,92,3,38,19,0,87,92,3,
        42,21,0,88,92,3,44,22,0,89,92,3,52,26,0,90,92,3,64,32,0,91,80,1,
        0,0,0,91,81,1,0,0,0,91,82,1,0,0,0,91,83,1,0,0,0,91,84,1,0,0,0,91,
        85,1,0,0,0,91,86,1,0,0,0,91,87,1,0,0,0,91,88,1,0,0,0,91,89,1,0,0,
        0,91,90,1,0,0,0,92,3,1,0,0,0,93,103,3,42,21,0,94,103,3,6,3,0,95,
        103,3,66,33,0,96,103,3,24,12,0,97,103,3,30,15,0,98,103,3,40,20,0,
        99,103,3,56,28,0,100,103,5,19,0,0,101,103,3,54,27,0,102,93,1,0,0,
        0,102,94,1,0,0,0,102,95,1,0,0,0,102,96,1,0,0,0,102,97,1,0,0,0,102,
        98,1,0,0,0,102,99,1,0,0,0,102,100,1,0,0,0,102,101,1,0,0,0,103,5,
        1,0,0,0,104,106,5,8,0,0,105,104,1,0,0,0,105,106,1,0,0,0,106,107,
        1,0,0,0,107,108,5,70,0,0,108,109,5,9,0,0,109,110,3,20,10,0,110,111,
        3,22,11,0,111,7,1,0,0,0,112,114,5,22,0,0,113,112,1,0,0,0,113,114,
        1,0,0,0,114,115,1,0,0,0,115,117,3,10,5,0,116,118,5,23,0,0,117,116,
        1,0,0,0,117,118,1,0,0,0,118,9,1,0,0,0,119,122,5,70,0,0,120,122,3,
        12,6,0,121,119,1,0,0,0,121,120,1,0,0,0,122,11,1,0,0,0,123,124,5,
        51,0,0,124,129,3,14,7,0,125,126,5,44,0,0,126,128,3,14,7,0,127,125,
        1,0,0,0,128,131,1,0,0,0,129,127,1,0,0,0,129,130,1,0,0,0,130,132,
        1,0,0,0,131,129,1,0,0,0,132,133,5,52,0,0,133,13,1,0,0,0,134,139,
        3,16,8,0,135,136,5,45,0,0,136,138,3,16,8,0,137,135,1,0,0,0,138,141,
        1,0,0,0,139,137,1,0,0,0,139,140,1,0,0,0,140,15,1,0,0,0,141,139,1,
        0,0,0,142,146,5,55,0,0,143,146,5,70,0,0,144,146,3,8,4,0,145,142,
        1,0,0,0,145,143,1,0,0,0,145,144,1,0,0,0,146,17,1,0,0,0,147,152,7,
        0,0,0,148,149,5,24,0,0,149,151,7,0,0,0,150,148,1,0,0,0,151,154,1,
        0,0,0,152,150,1,0,0,0,152,153,1,0,0,0,153,19,1,0,0,0,154,152,1,0,
        0,0,155,169,3,32,16,0,156,169,3,36,18,0,157,169,3,58,29,0,158,169,
        3,68,34,0,159,169,3,8,4,0,160,169,3,18,9,0,161,169,5,55,0,0,162,
        169,5,56,0,0,163,169,5,70,0,0,164,165,5,53,0,0,165,166,3,20,10,0,
        166,167,5,54,0,0,167,169,1,0,0,0,168,155,1,0,0,0,168,156,1,0,0,0,
        168,157,1,0,0,0,168,158,1,0,0,0,168,159,1,0,0,0,168,160,1,0,0,0,
        168,161,1,0,0,0,168,162,1,0,0,0,168,163,1,0,0,0,168,164,1,0,0,0,
        169,21,1,0,0,0,170,171,7,1,0,0,171,23,1,0,0,0,172,173,5,3,0,0,173,
        174,5,70,0,0,174,176,5,53,0,0,175,177,3,26,13,0,176,175,1,0,0,0,
        176,177,1,0,0,0,177,178,1,0,0,0,178,179,5,54,0,0,179,180,3,56,28,
        0,180,181,5,4,0,0,181,25,1,0,0,0,182,187,3,28,14,0,183,184,5,45,
        0,0,184,186,3,28,14,0,185,183,1,0,0,0,186,189,1,0,0,0,187,185,1,
        0,0,0,187,188,1,0,0,0,188,27,1,0,0,0,189,187,1,0,0,0,190,191,5,70,
        0,0,191,192,3,22,11,0,192,29,1,0,0,0,193,194,5,5,0,0,194,195,3,20,
        10,0,195,31,1,0,0,0,196,198,5,6,0,0,197,196,1,0,0,0,197,198,1,0,
        0,0,198,199,1,0,0,0,199,200,5,70,0,0,200,202,5,53,0,0,201,203,3,
        34,17,0,202,201,1,0,0,0,202,203,1,0,0,0,203,204,1,0,0,0,204,205,
        5,54,0,0,205,33,1,0,0,0,206,211,3,20,10,0,207,208,5,45,0,0,208,210,
        3,20,10,0,209,207,1,0,0,0,210,213,1,0,0,0,211,209,1,0,0,0,211,212,
        1,0,0,0,212,35,1,0,0,0,213,211,1,0,0,0,214,215,5,65,0,0,215,216,
        5,53,0,0,216,217,3,58,29,0,217,218,5,45,0,0,218,219,3,58,29,0,219,
        220,5,54,0,0,220,227,1,0,0,0,221,222,7,2,0,0,222,223,5,53,0,0,223,
        224,3,58,29,0,224,225,5,54,0,0,225,227,1,0,0,0,226,214,1,0,0,0,226,
        221,1,0,0,0,227,37,1,0,0,0,228,229,5,11,0,0,229,230,5,53,0,0,230,
        231,3,68,34,0,231,234,5,54,0,0,232,235,3,2,1,0,233,235,3,56,28,0,
        234,232,1,0,0,0,234,233,1,0,0,0,235,246,1,0,0,0,236,237,5,12,0,0,
        237,238,5,53,0,0,238,239,3,68,34,0,239,242,5,54,0,0,240,243,3,2,
        1,0,241,243,3,56,28,0,242,240,1,0,0,0,242,241,1,0,0,0,243,245,1,
        0,0,0,244,236,1,0,0,0,245,248,1,0,0,0,246,244,1,0,0,0,246,247,1,
        0,0,0,247,254,1,0,0,0,248,246,1,0,0,0,249,252,5,13,0,0,250,253,3,
        2,1,0,251,253,3,56,28,0,252,250,1,0,0,0,252,251,1,0,0,0,253,255,
        1,0,0,0,254,249,1,0,0,0,254,255,1,0,0,0,255,39,1,0,0,0,256,257,5,
        11,0,0,257,258,5,53,0,0,258,259,3,68,34,0,259,269,5,54,0,0,260,262,
        5,51,0,0,261,263,3,4,2,0,262,261,1,0,0,0,263,264,1,0,0,0,264,262,
        1,0,0,0,264,265,1,0,0,0,265,266,1,0,0,0,266,267,5,52,0,0,267,270,
        1,0,0,0,268,270,3,2,1,0,269,260,1,0,0,0,269,268,1,0,0,0,270,288,
        1,0,0,0,271,272,5,12,0,0,272,273,5,53,0,0,273,274,3,68,34,0,274,
        284,5,54,0,0,275,277,5,51,0,0,276,278,3,4,2,0,277,276,1,0,0,0,278,
        279,1,0,0,0,279,277,1,0,0,0,279,280,1,0,0,0,280,281,1,0,0,0,281,
        282,5,52,0,0,282,285,1,0,0,0,283,285,3,2,1,0,284,275,1,0,0,0,284,
        283,1,0,0,0,285,287,1,0,0,0,286,271,1,0,0,0,287,290,1,0,0,0,288,
        286,1,0,0,0,288,289,1,0,0,0,289,303,1,0,0,0,290,288,1,0,0,0,291,
        301,5,13,0,0,292,294,5,51,0,0,293,295,3,4,2,0,294,293,1,0,0,0,295,
        296,1,0,0,0,296,294,1,0,0,0,296,297,1,0,0,0,297,298,1,0,0,0,298,
        299,5,52,0,0,299,302,1,0,0,0,300,302,3,2,1,0,301,292,1,0,0,0,301,
        300,1,0,0,0,302,304,1,0,0,0,303,291,1,0,0,0,303,304,1,0,0,0,304,
        41,1,0,0,0,305,308,3,44,22,0,306,308,3,52,26,0,307,305,1,0,0,0,307,
        306,1,0,0,0,308,43,1,0,0,0,309,310,5,15,0,0,310,312,5,53,0,0,311,
        313,3,46,23,0,312,311,1,0,0,0,312,313,1,0,0,0,313,314,1,0,0,0,314,
        315,5,44,0,0,315,316,3,68,34,0,316,317,5,44,0,0,317,318,3,48,24,
        0,318,319,5,54,0,0,319,320,3,50,25,0,320,45,1,0,0,0,321,324,5,70,
        0,0,322,324,3,6,3,0,323,321,1,0,0,0,323,322,1,0,0,0,324,47,1,0,0,
        0,325,329,3,6,3,0,326,329,3,66,33,0,327,329,3,64,32,0,328,325,1,
        0,0,0,328,326,1,0,0,0,328,327,1,0,0,0,329,49,1,0,0,0,330,332,5,51,
        0,0,331,333,3,4,2,0,332,331,1,0,0,0,333,334,1,0,0,0,334,332,1,0,
        0,0,334,335,1,0,0,0,335,336,1,0,0,0,336,337,5,52,0,0,337,340,1,0,
        0,0,338,340,3,2,1,0,339,330,1,0,0,0,339,338,1,0,0,0,340,51,1,0,0,
        0,341,342,5,20,0,0,342,343,5,53,0,0,343,344,3,68,34,0,344,354,5,
        54,0,0,345,347,5,51,0,0,346,348,3,4,2,0,347,346,1,0,0,0,348,349,
        1,0,0,0,349,347,1,0,0,0,349,350,1,0,0,0,350,351,1,0,0,0,351,352,
        5,52,0,0,352,355,1,0,0,0,353,355,3,2,1,0,354,345,1,0,0,0,354,353,
        1,0,0,0,355,53,1,0,0,0,356,357,5,10,0,0,357,362,3,20,10,0,358,359,
        5,45,0,0,359,361,3,20,10,0,360,358,1,0,0,0,361,364,1,0,0,0,362,360,
        1,0,0,0,362,363,1,0,0,0,363,55,1,0,0,0,364,362,1,0,0,0,365,367,5,
        51,0,0,366,368,3,2,1,0,367,366,1,0,0,0,368,369,1,0,0,0,369,367,1,
        0,0,0,369,370,1,0,0,0,370,371,1,0,0,0,371,372,5,52,0,0,372,57,1,
        0,0,0,373,374,6,29,-1,0,374,375,3,60,30,0,375,381,1,0,0,0,376,377,
        10,2,0,0,377,378,7,3,0,0,378,380,3,60,30,0,379,376,1,0,0,0,380,383,
        1,0,0,0,381,379,1,0,0,0,381,382,1,0,0,0,382,59,1,0,0,0,383,381,1,
        0,0,0,384,385,6,30,-1,0,385,386,3,62,31,0,386,392,1,0,0,0,387,388,
        10,2,0,0,388,389,7,4,0,0,389,391,3,62,31,0,390,387,1,0,0,0,391,394,
        1,0,0,0,392,390,1,0,0,0,392,393,1,0,0,0,393,61,1,0,0,0,394,392,1,
        0,0,0,395,405,3,32,16,0,396,405,5,55,0,0,397,405,5,70,0,0,398,405,
        5,56,0,0,399,405,3,64,32,0,400,401,5,53,0,0,401,402,3,58,29,0,402,
        403,5,54,0,0,403,405,1,0,0,0,404,395,1,0,0,0,404,396,1,0,0,0,404,
        397,1,0,0,0,404,398,1,0,0,0,404,399,1,0,0,0,404,400,1,0,0,0,405,
        63,1,0,0,0,406,407,5,70,0,0,407,410,7,5,0,0,408,410,3,32,16,0,409,
        406,1,0,0,0,409,408,1,0,0,0,410,65,1,0,0,0,411,424,5,70,0,0,412,
        413,5,34,0,0,413,417,5,56,0,0,414,415,5,34,0,0,415,417,3,58,29,0,
        416,412,1,0,0,0,416,414,1,0,0,0,417,425,1,0,0,0,418,419,5,35,0,0,
        419,425,3,58,29,0,420,421,5,39,0,0,421,425,3,58,29,0,422,423,5,38,
        0,0,423,425,3,58,29,0,424,416,1,0,0,0,424,418,1,0,0,0,424,420,1,
        0,0,0,424,422,1,0,0,0,425,426,1,0,0,0,426,427,5,44,0,0,427,67,1,
        0,0,0,428,429,6,34,-1,0,429,430,3,58,29,0,430,431,3,70,35,0,431,
        432,3,58,29,0,432,455,1,0,0,0,433,434,3,18,9,0,434,435,7,6,0,0,435,
        436,3,18,9,0,436,455,1,0,0,0,437,438,3,8,4,0,438,439,7,6,0,0,439,
        440,3,8,4,0,440,455,1,0,0,0,441,443,5,43,0,0,442,441,1,0,0,0,442,
        443,1,0,0,0,443,444,1,0,0,0,444,445,5,53,0,0,445,446,3,68,34,0,446,
        447,5,54,0,0,447,455,1,0,0,0,448,455,5,63,0,0,449,455,5,64,0,0,450,
        452,5,43,0,0,451,450,1,0,0,0,451,452,1,0,0,0,452,453,1,0,0,0,453,
        455,5,70,0,0,454,428,1,0,0,0,454,433,1,0,0,0,454,437,1,0,0,0,454,
        442,1,0,0,0,454,448,1,0,0,0,454,449,1,0,0,0,454,451,1,0,0,0,455,
        461,1,0,0,0,456,457,10,5,0,0,457,458,7,7,0,0,458,460,3,68,34,6,459,
        456,1,0,0,0,460,463,1,0,0,0,461,459,1,0,0,0,461,462,1,0,0,0,462,
        69,1,0,0,0,463,461,1,0,0,0,464,465,7,8,0,0,465,71,1,0,0,0,51,76,
        91,102,105,113,117,121,129,139,145,152,168,176,187,197,202,211,226,
        234,242,246,252,254,264,269,279,284,288,296,301,303,307,312,323,
        328,334,339,349,354,362,369,381,392,404,409,416,424,442,451,454,
        461
    ]

class EnglishLangParser ( Parser ):

    grammarFileName = "EnglishLangParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'Start Program'", "'End Program'", "'Define Function'", 
                     "'End Function'", "'Return'", "'Call'", "'with'", "'Set'", 
                     "'to'", "'Display'", "'If'", "'Else If'", "'Else'", 
                     "'End If'", "'For'", "'from'", "'in'", "'End For'", 
                     "'break'", "'While'", "'End While'", "'invert'", "''T'", 
                     "'+'", "'-'", "'*'", "'/'", "'%'", "'=='", "'>'", "'<'", 
                     "'>='", "'<='", "'+='", "'-='", "'++'", "'--'", "'*='", 
                     "'/='", "'!='", "'and'", "'or'", "'not'", "';'", "','", 
                     "':'", "'.'", "'\"'", "'['", "']'", "'{'", "'}'", "'('", 
                     "')'", "<INVALID>", "<INVALID>", "'int'", "'string'", 
                     "'bool'", "'float'", "'matrix'", "'void'", "'true'", 
                     "'false'", "'pow'", "'sin'", "'cos'", "'tan'", "'ctan'" ]

    symbolicNames = [ "<INVALID>", "START_PROGRAM", "END_PROGRAM", "DEFINE_FUNCTION", 
                      "END_FUNCTION", "RETURN", "CALL", "WITH", "SET", "TO", 
                      "DISPLAY", "IF", "ELSE_IF", "ELSE", "END_IF", "FOR", 
                      "FROM", "IN", "END_FOR", "BREAK", "WHILE", "END_WHILE", 
                      "INVERT_MATRIX", "TRANSPOSITION", "PLUS", "MINUS", 
                      "MULTIPLY", "DIVIDED_BY", "MODULO", "EQUALS", "GREATER_THAN", 
                      "LESS_THAN", "GREATER_EQUAL", "LESS_EQUAL", "ADD_TO", 
                      "SUBTRACT_FROM", "INCREMENT", "DECREMENT", "TIMES", 
                      "DIVIDE_FROM", "NOT_EQUALS", "AND", "OR", "NOT", "SEMICOLON", 
                      "COMMA", "COLON", "DOT", "QUOTE", "LBRACK", "RBRACK", 
                      "LBRACE", "RBRACE", "LPAREN", "RPAREN", "NUMBER", 
                      "STRING", "TYPE_INT", "TYPE_STRING", "TYPE_BOOL", 
                      "TYPE_FLOAT", "TYPE_MATRIX", "TYPE_VOID", "TRUE_VALUE", 
                      "FALSE_VALUE", "POWER_FUNC", "SIN_FUNC", "COS_FUNC", 
                      "TAN_FUNC", "CTAN_FUNC", "IDENTIFIER", "WS", "COMMENT" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_loopStatements = 2
    RULE_variableDeclaration = 3
    RULE_matrixExpression = 4
    RULE_matrixAtom = 5
    RULE_matrixConstruction = 6
    RULE_row = 7
    RULE_value = 8
    RULE_stringExpression = 9
    RULE_expression = 10
    RULE_typeAnnotation = 11
    RULE_functionDeclaration = 12
    RULE_parameter = 13
    RULE_typedParameter = 14
    RULE_returnStatement = 15
    RULE_functionCall = 16
    RULE_argumentList = 17
    RULE_builtInFunctions = 18
    RULE_ifStatement = 19
    RULE_loopIfStatement = 20
    RULE_loopStatement = 21
    RULE_forLoop = 22
    RULE_forInit = 23
    RULE_forUpdate = 24
    RULE_forBody = 25
    RULE_whileLoop = 26
    RULE_displayStatement = 27
    RULE_block = 28
    RULE_numExpression = 29
    RULE_term = 30
    RULE_factor = 31
    RULE_operation = 32
    RULE_reassignment = 33
    RULE_boolExpression = 34
    RULE_comparisonOp = 35

    ruleNames =  [ "program", "statement", "loopStatements", "variableDeclaration", 
                   "matrixExpression", "matrixAtom", "matrixConstruction", 
                   "row", "value", "stringExpression", "expression", "typeAnnotation", 
                   "functionDeclaration", "parameter", "typedParameter", 
                   "returnStatement", "functionCall", "argumentList", "builtInFunctions", 
                   "ifStatement", "loopIfStatement", "loopStatement", "forLoop", 
                   "forInit", "forUpdate", "forBody", "whileLoop", "displayStatement", 
                   "block", "numExpression", "term", "factor", "operation", 
                   "reassignment", "boolExpression", "comparisonOp" ]

    EOF = Token.EOF
    START_PROGRAM=1
    END_PROGRAM=2
    DEFINE_FUNCTION=3
    END_FUNCTION=4
    RETURN=5
    CALL=6
    WITH=7
    SET=8
    TO=9
    DISPLAY=10
    IF=11
    ELSE_IF=12
    ELSE=13
    END_IF=14
    FOR=15
    FROM=16
    IN=17
    END_FOR=18
    BREAK=19
    WHILE=20
    END_WHILE=21
    INVERT_MATRIX=22
    TRANSPOSITION=23
    PLUS=24
    MINUS=25
    MULTIPLY=26
    DIVIDED_BY=27
    MODULO=28
    EQUALS=29
    GREATER_THAN=30
    LESS_THAN=31
    GREATER_EQUAL=32
    LESS_EQUAL=33
    ADD_TO=34
    SUBTRACT_FROM=35
    INCREMENT=36
    DECREMENT=37
    TIMES=38
    DIVIDE_FROM=39
    NOT_EQUALS=40
    AND=41
    OR=42
    NOT=43
    SEMICOLON=44
    COMMA=45
    COLON=46
    DOT=47
    QUOTE=48
    LBRACK=49
    RBRACK=50
    LBRACE=51
    RBRACE=52
    LPAREN=53
    RPAREN=54
    NUMBER=55
    STRING=56
    TYPE_INT=57
    TYPE_STRING=58
    TYPE_BOOL=59
    TYPE_FLOAT=60
    TYPE_MATRIX=61
    TYPE_VOID=62
    TRUE_VALUE=63
    FALSE_VALUE=64
    POWER_FUNC=65
    SIN_FUNC=66
    COS_FUNC=67
    TAN_FUNC=68
    CTAN_FUNC=69
    IDENTIFIER=70
    WS=71
    COMMENT=72

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def START_PROGRAM(self):
            return self.getToken(EnglishLangParser.START_PROGRAM, 0)

        def END_PROGRAM(self):
            return self.getToken(EnglishLangParser.END_PROGRAM, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = EnglishLangParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.match(EnglishLangParser.START_PROGRAM)
            self.state = 74 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 73
                self.statement()
                self.state = 76 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1084776) != 0) or _la==70):
                    break

            self.state = 78
            self.match(EnglishLangParser.END_PROGRAM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(EnglishLangParser.ReassignmentContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionDeclarationContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionCallContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.ReturnStatementContext,0)


        def displayStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.DisplayStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.IfStatementContext,0)


        def loopStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.LoopStatementContext,0)


        def forLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.ForLoopContext,0)


        def whileLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.WhileLoopContext,0)


        def operation(self):
            return self.getTypedRuleContext(EnglishLangParser.OperationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = EnglishLangParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 91
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 80
                self.variableDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 81
                self.reassignment()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 82
                self.functionDeclaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 83
                self.functionCall()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 84
                self.returnStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 85
                self.displayStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 86
                self.ifStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 87
                self.loopStatement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 88
                self.forLoop()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 89
                self.whileLoop()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 90
                self.operation()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopStatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.LoopStatementContext,0)


        def variableDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(EnglishLangParser.ReassignmentContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionDeclarationContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.ReturnStatementContext,0)


        def loopIfStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.LoopIfStatementContext,0)


        def block(self):
            return self.getTypedRuleContext(EnglishLangParser.BlockContext,0)


        def BREAK(self):
            return self.getToken(EnglishLangParser.BREAK, 0)

        def displayStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.DisplayStatementContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_loopStatements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopStatements" ):
                listener.enterLoopStatements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopStatements" ):
                listener.exitLoopStatements(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopStatements" ):
                return visitor.visitLoopStatements(self)
            else:
                return visitor.visitChildren(self)




    def loopStatements(self):

        localctx = EnglishLangParser.LoopStatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_loopStatements)
        try:
            self.state = 102
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 93
                self.loopStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 94
                self.variableDeclaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 95
                self.reassignment()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 96
                self.functionDeclaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 97
                self.returnStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 98
                self.loopIfStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 99
                self.block()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 100
                self.match(EnglishLangParser.BREAK)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 101
                self.displayStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def TO(self):
            return self.getToken(EnglishLangParser.TO, 0)

        def expression(self):
            return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,0)


        def typeAnnotation(self):
            return self.getTypedRuleContext(EnglishLangParser.TypeAnnotationContext,0)


        def SET(self):
            return self.getToken(EnglishLangParser.SET, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_variableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclaration" ):
                listener.enterVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclaration" ):
                listener.exitVariableDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclaration" ):
                return visitor.visitVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclaration(self):

        localctx = EnglishLangParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_variableDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 104
                self.match(EnglishLangParser.SET)


            self.state = 107
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 108
            self.match(EnglishLangParser.TO)
            self.state = 109
            self.expression()
            self.state = 110
            self.typeAnnotation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def matrixAtom(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixAtomContext,0)


        def INVERT_MATRIX(self):
            return self.getToken(EnglishLangParser.INVERT_MATRIX, 0)

        def TRANSPOSITION(self):
            return self.getToken(EnglishLangParser.TRANSPOSITION, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_matrixExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixExpression" ):
                listener.enterMatrixExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixExpression" ):
                listener.exitMatrixExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixExpression" ):
                return visitor.visitMatrixExpression(self)
            else:
                return visitor.visitChildren(self)




    def matrixExpression(self):

        localctx = EnglishLangParser.MatrixExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_matrixExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 112
                self.match(EnglishLangParser.INVERT_MATRIX)


            self.state = 115
            self.matrixAtom()
            self.state = 117
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 116
                self.match(EnglishLangParser.TRANSPOSITION)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixAtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def matrixConstruction(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixConstructionContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_matrixAtom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixAtom" ):
                listener.enterMatrixAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixAtom" ):
                listener.exitMatrixAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixAtom" ):
                return visitor.visitMatrixAtom(self)
            else:
                return visitor.visitChildren(self)




    def matrixAtom(self):

        localctx = EnglishLangParser.MatrixAtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_matrixAtom)
        try:
            self.state = 121
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [70]:
                self.enterOuterAlt(localctx, 1)
                self.state = 119
                self.match(EnglishLangParser.IDENTIFIER)
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 2)
                self.state = 120
                self.matrixConstruction()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixConstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def row(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.RowContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.RowContext,i)


        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.SEMICOLON)
            else:
                return self.getToken(EnglishLangParser.SEMICOLON, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_matrixConstruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixConstruction" ):
                listener.enterMatrixConstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixConstruction" ):
                listener.exitMatrixConstruction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixConstruction" ):
                return visitor.visitMatrixConstruction(self)
            else:
                return visitor.visitChildren(self)




    def matrixConstruction(self):

        localctx = EnglishLangParser.MatrixConstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_matrixConstruction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.match(EnglishLangParser.LBRACE)
            self.state = 124
            self.row()
            self.state = 129
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==44:
                self.state = 125
                self.match(EnglishLangParser.SEMICOLON)
                self.state = 126
                self.row()
                self.state = 131
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 132
            self.match(EnglishLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.ValueContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.ValueContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_row

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRow" ):
                listener.enterRow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRow" ):
                listener.exitRow(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRow" ):
                return visitor.visitRow(self)
            else:
                return visitor.visitChildren(self)




    def row(self):

        localctx = EnglishLangParser.RowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_row)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            self.value()
            self.state = 139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==45:
                self.state = 135
                self.match(EnglishLangParser.COMMA)
                self.state = 136
                self.value()
                self.state = 141
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(EnglishLangParser.NUMBER, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def matrixExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixExpressionContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue" ):
                listener.enterValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue" ):
                listener.exitValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValue" ):
                return visitor.visitValue(self)
            else:
                return visitor.visitChildren(self)




    def value(self):

        localctx = EnglishLangParser.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_value)
        try:
            self.state = 145
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 142
                self.match(EnglishLangParser.NUMBER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 143
                self.match(EnglishLangParser.IDENTIFIER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 144
                self.matrixExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.STRING)
            else:
                return self.getToken(EnglishLangParser.STRING, i)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.IDENTIFIER)
            else:
                return self.getToken(EnglishLangParser.IDENTIFIER, i)

        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.PLUS)
            else:
                return self.getToken(EnglishLangParser.PLUS, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_stringExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringExpression" ):
                listener.enterStringExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringExpression" ):
                listener.exitStringExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringExpression" ):
                return visitor.visitStringExpression(self)
            else:
                return visitor.visitChildren(self)




    def stringExpression(self):

        localctx = EnglishLangParser.StringExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_stringExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 147
            _la = self._input.LA(1)
            if not(_la==56 or _la==70):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 152
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 148
                    self.match(EnglishLangParser.PLUS)
                    self.state = 149
                    _la = self._input.LA(1)
                    if not(_la==56 or _la==70):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 154
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionCall(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionCallContext,0)


        def builtInFunctions(self):
            return self.getTypedRuleContext(EnglishLangParser.BuiltInFunctionsContext,0)


        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)


        def matrixExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixExpressionContext,0)


        def stringExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.StringExpressionContext,0)


        def NUMBER(self):
            return self.getToken(EnglishLangParser.NUMBER, 0)

        def STRING(self):
            return self.getToken(EnglishLangParser.STRING, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,0)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = EnglishLangParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_expression)
        try:
            self.state = 168
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 155
                self.functionCall()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 156
                self.builtInFunctions()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 157
                self.numExpression(0)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 158
                self.boolExpression(0)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 159
                self.matrixExpression()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 160
                self.stringExpression()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 161
                self.match(EnglishLangParser.NUMBER)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 162
                self.match(EnglishLangParser.STRING)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 163
                self.match(EnglishLangParser.IDENTIFIER)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 164
                self.match(EnglishLangParser.LPAREN)
                self.state = 165
                self.expression()
                self.state = 166
                self.match(EnglishLangParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeAnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE_STRING(self):
            return self.getToken(EnglishLangParser.TYPE_STRING, 0)

        def TYPE_INT(self):
            return self.getToken(EnglishLangParser.TYPE_INT, 0)

        def TYPE_FLOAT(self):
            return self.getToken(EnglishLangParser.TYPE_FLOAT, 0)

        def TYPE_BOOL(self):
            return self.getToken(EnglishLangParser.TYPE_BOOL, 0)

        def TYPE_MATRIX(self):
            return self.getToken(EnglishLangParser.TYPE_MATRIX, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_typeAnnotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeAnnotation" ):
                listener.enterTypeAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeAnnotation" ):
                listener.exitTypeAnnotation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeAnnotation" ):
                return visitor.visitTypeAnnotation(self)
            else:
                return visitor.visitChildren(self)




    def typeAnnotation(self):

        localctx = EnglishLangParser.TypeAnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_typeAnnotation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 4467570830351532032) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE_FUNCTION(self):
            return self.getToken(EnglishLangParser.DEFINE_FUNCTION, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def block(self):
            return self.getTypedRuleContext(EnglishLangParser.BlockContext,0)


        def END_FUNCTION(self):
            return self.getToken(EnglishLangParser.END_FUNCTION, 0)

        def parameter(self):
            return self.getTypedRuleContext(EnglishLangParser.ParameterContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_functionDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDeclaration" ):
                listener.enterFunctionDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDeclaration" ):
                listener.exitFunctionDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDeclaration" ):
                return visitor.visitFunctionDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def functionDeclaration(self):

        localctx = EnglishLangParser.FunctionDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_functionDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.match(EnglishLangParser.DEFINE_FUNCTION)
            self.state = 173
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 174
            self.match(EnglishLangParser.LPAREN)
            self.state = 176
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==70:
                self.state = 175
                self.parameter()


            self.state = 178
            self.match(EnglishLangParser.RPAREN)
            self.state = 179
            self.block()
            self.state = 180
            self.match(EnglishLangParser.END_FUNCTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typedParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.TypedParameterContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.TypedParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = EnglishLangParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_parameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.typedParameter()
            self.state = 187
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==45:
                self.state = 183
                self.match(EnglishLangParser.COMMA)
                self.state = 184
                self.typedParameter()
                self.state = 189
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypedParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def typeAnnotation(self):
            return self.getTypedRuleContext(EnglishLangParser.TypeAnnotationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_typedParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypedParameter" ):
                listener.enterTypedParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypedParameter" ):
                listener.exitTypedParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypedParameter" ):
                return visitor.visitTypedParameter(self)
            else:
                return visitor.visitChildren(self)




    def typedParameter(self):

        localctx = EnglishLangParser.TypedParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_typedParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 191
            self.typeAnnotation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(EnglishLangParser.RETURN, 0)

        def expression(self):
            return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_returnStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStatement" ):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)




    def returnStatement(self):

        localctx = EnglishLangParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(EnglishLangParser.RETURN)
            self.state = 194
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def CALL(self):
            return self.getToken(EnglishLangParser.CALL, 0)

        def argumentList(self):
            return self.getTypedRuleContext(EnglishLangParser.ArgumentListContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = EnglishLangParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_functionCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 196
                self.match(EnglishLangParser.CALL)


            self.state = 199
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 200
            self.match(EnglishLangParser.LPAREN)
            self.state = 202
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & -9104017850632241088) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 127) != 0):
                self.state = 201
                self.argumentList()


            self.state = 204
            self.match(EnglishLangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentList" ):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)




    def argumentList(self):

        localctx = EnglishLangParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self.expression()
            self.state = 211
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==45:
                self.state = 207
                self.match(EnglishLangParser.COMMA)
                self.state = 208
                self.expression()
                self.state = 213
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BuiltInFunctionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POWER_FUNC(self):
            return self.getToken(EnglishLangParser.POWER_FUNC, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def numExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.NumExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,i)


        def COMMA(self):
            return self.getToken(EnglishLangParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def SIN_FUNC(self):
            return self.getToken(EnglishLangParser.SIN_FUNC, 0)

        def COS_FUNC(self):
            return self.getToken(EnglishLangParser.COS_FUNC, 0)

        def TAN_FUNC(self):
            return self.getToken(EnglishLangParser.TAN_FUNC, 0)

        def CTAN_FUNC(self):
            return self.getToken(EnglishLangParser.CTAN_FUNC, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_builtInFunctions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBuiltInFunctions" ):
                listener.enterBuiltInFunctions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBuiltInFunctions" ):
                listener.exitBuiltInFunctions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBuiltInFunctions" ):
                return visitor.visitBuiltInFunctions(self)
            else:
                return visitor.visitChildren(self)




    def builtInFunctions(self):

        localctx = EnglishLangParser.BuiltInFunctionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_builtInFunctions)
        self._la = 0 # Token type
        try:
            self.state = 226
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [65]:
                self.enterOuterAlt(localctx, 1)
                self.state = 214
                self.match(EnglishLangParser.POWER_FUNC)
                self.state = 215
                self.match(EnglishLangParser.LPAREN)
                self.state = 216
                self.numExpression(0)
                self.state = 217
                self.match(EnglishLangParser.COMMA)
                self.state = 218
                self.numExpression(0)
                self.state = 219
                self.match(EnglishLangParser.RPAREN)
                pass
            elif token in [66, 67, 68, 69]:
                self.enterOuterAlt(localctx, 2)
                self.state = 221
                _la = self._input.LA(1)
                if not(((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 15) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 222
                self.match(EnglishLangParser.LPAREN)
                self.state = 223
                self.numExpression(0)
                self.state = 224
                self.match(EnglishLangParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(EnglishLangParser.IF, 0)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.LPAREN)
            else:
                return self.getToken(EnglishLangParser.LPAREN, i)

        def boolExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,i)


        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.RPAREN)
            else:
                return self.getToken(EnglishLangParser.RPAREN, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def block(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BlockContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BlockContext,i)


        def ELSE_IF(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.ELSE_IF)
            else:
                return self.getToken(EnglishLangParser.ELSE_IF, i)

        def ELSE(self):
            return self.getToken(EnglishLangParser.ELSE, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStatement(self):

        localctx = EnglishLangParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_ifStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 228
            self.match(EnglishLangParser.IF)
            self.state = 229
            self.match(EnglishLangParser.LPAREN)
            self.state = 230
            self.boolExpression(0)
            self.state = 231
            self.match(EnglishLangParser.RPAREN)
            self.state = 234
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                self.state = 232
                self.statement()
                pass
            elif token in [51]:
                self.state = 233
                self.block()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 246
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,20,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 236
                    self.match(EnglishLangParser.ELSE_IF)
                    self.state = 237
                    self.match(EnglishLangParser.LPAREN)
                    self.state = 238
                    self.boolExpression(0)
                    self.state = 239
                    self.match(EnglishLangParser.RPAREN)
                    self.state = 242
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                        self.state = 240
                        self.statement()
                        pass
                    elif token in [51]:
                        self.state = 241
                        self.block()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 248
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

            self.state = 254
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.state = 249
                self.match(EnglishLangParser.ELSE)
                self.state = 252
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                    self.state = 250
                    self.statement()
                    pass
                elif token in [51]:
                    self.state = 251
                    self.block()
                    pass
                else:
                    raise NoViableAltException(self)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopIfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(EnglishLangParser.IF, 0)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.LPAREN)
            else:
                return self.getToken(EnglishLangParser.LPAREN, i)

        def boolExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,i)


        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.RPAREN)
            else:
                return self.getToken(EnglishLangParser.RPAREN, i)

        def LBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.LBRACE)
            else:
                return self.getToken(EnglishLangParser.LBRACE, i)

        def RBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.RBRACE)
            else:
                return self.getToken(EnglishLangParser.RBRACE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def ELSE_IF(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.ELSE_IF)
            else:
                return self.getToken(EnglishLangParser.ELSE_IF, i)

        def ELSE(self):
            return self.getToken(EnglishLangParser.ELSE, 0)

        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.LoopStatementsContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_loopIfStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopIfStatement" ):
                listener.enterLoopIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopIfStatement" ):
                listener.exitLoopIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopIfStatement" ):
                return visitor.visitLoopIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def loopIfStatement(self):

        localctx = EnglishLangParser.LoopIfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_loopIfStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 256
            self.match(EnglishLangParser.IF)
            self.state = 257
            self.match(EnglishLangParser.LPAREN)
            self.state = 258
            self.boolExpression(0)
            self.state = 259
            self.match(EnglishLangParser.RPAREN)
            self.state = 269
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51]:
                self.state = 260
                self.match(EnglishLangParser.LBRACE)
                self.state = 262 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 261
                    self.loopStatements()
                    self.state = 264 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815294248) != 0) or _la==70):
                        break

                self.state = 266
                self.match(EnglishLangParser.RBRACE)
                pass
            elif token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                self.state = 268
                self.statement()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 288
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==12:
                self.state = 271
                self.match(EnglishLangParser.ELSE_IF)
                self.state = 272
                self.match(EnglishLangParser.LPAREN)
                self.state = 273
                self.boolExpression(0)
                self.state = 274
                self.match(EnglishLangParser.RPAREN)
                self.state = 284
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [51]:
                    self.state = 275
                    self.match(EnglishLangParser.LBRACE)
                    self.state = 277 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 276
                        self.loopStatements()
                        self.state = 279 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815294248) != 0) or _la==70):
                            break

                    self.state = 281
                    self.match(EnglishLangParser.RBRACE)
                    pass
                elif token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                    self.state = 283
                    self.statement()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 290
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 303
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 291
                self.match(EnglishLangParser.ELSE)
                self.state = 301
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [51]:
                    self.state = 292
                    self.match(EnglishLangParser.LBRACE)
                    self.state = 294 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 293
                        self.loopStatements()
                        self.state = 296 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815294248) != 0) or _la==70):
                            break

                    self.state = 298
                    self.match(EnglishLangParser.RBRACE)
                    pass
                elif token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                    self.state = 300
                    self.statement()
                    pass
                else:
                    raise NoViableAltException(self)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.ForLoopContext,0)


        def whileLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.WhileLoopContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_loopStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopStatement" ):
                listener.enterLoopStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopStatement" ):
                listener.exitLoopStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopStatement" ):
                return visitor.visitLoopStatement(self)
            else:
                return visitor.visitChildren(self)




    def loopStatement(self):

        localctx = EnglishLangParser.LoopStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_loopStatement)
        try:
            self.state = 307
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [15]:
                self.enterOuterAlt(localctx, 1)
                self.state = 305
                self.forLoop()
                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 2)
                self.state = 306
                self.whileLoop()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForLoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.cond = None # BoolExpressionContext

        def FOR(self):
            return self.getToken(EnglishLangParser.FOR, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.SEMICOLON)
            else:
                return self.getToken(EnglishLangParser.SEMICOLON, i)

        def forUpdate(self):
            return self.getTypedRuleContext(EnglishLangParser.ForUpdateContext,0)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def forBody(self):
            return self.getTypedRuleContext(EnglishLangParser.ForBodyContext,0)


        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)


        def forInit(self):
            return self.getTypedRuleContext(EnglishLangParser.ForInitContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_forLoop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForLoop" ):
                listener.enterForLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForLoop" ):
                listener.exitForLoop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForLoop" ):
                return visitor.visitForLoop(self)
            else:
                return visitor.visitChildren(self)




    def forLoop(self):

        localctx = EnglishLangParser.ForLoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_forLoop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 309
            self.match(EnglishLangParser.FOR)
            self.state = 310
            self.match(EnglishLangParser.LPAREN)
            self.state = 312
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8 or _la==70:
                self.state = 311
                self.forInit()


            self.state = 314
            self.match(EnglishLangParser.SEMICOLON)
            self.state = 315
            localctx.cond = self.boolExpression(0)
            self.state = 316
            self.match(EnglishLangParser.SEMICOLON)
            self.state = 317
            self.forUpdate()
            self.state = 318
            self.match(EnglishLangParser.RPAREN)
            self.state = 319
            self.forBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForInitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def variableDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_forInit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForInit" ):
                listener.enterForInit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForInit" ):
                listener.exitForInit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForInit" ):
                return visitor.visitForInit(self)
            else:
                return visitor.visitChildren(self)




    def forInit(self):

        localctx = EnglishLangParser.ForInitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_forInit)
        try:
            self.state = 323
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 321
                self.match(EnglishLangParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 322
                self.variableDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForUpdateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(EnglishLangParser.ReassignmentContext,0)


        def operation(self):
            return self.getTypedRuleContext(EnglishLangParser.OperationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_forUpdate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForUpdate" ):
                listener.enterForUpdate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForUpdate" ):
                listener.exitForUpdate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForUpdate" ):
                return visitor.visitForUpdate(self)
            else:
                return visitor.visitChildren(self)




    def forUpdate(self):

        localctx = EnglishLangParser.ForUpdateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_forUpdate)
        try:
            self.state = 328
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 325
                self.variableDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 326
                self.reassignment()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 327
                self.operation()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.LoopStatementsContext,i)


        def statement(self):
            return self.getTypedRuleContext(EnglishLangParser.StatementContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_forBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForBody" ):
                listener.enterForBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForBody" ):
                listener.exitForBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForBody" ):
                return visitor.visitForBody(self)
            else:
                return visitor.visitChildren(self)




    def forBody(self):

        localctx = EnglishLangParser.ForBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_forBody)
        self._la = 0 # Token type
        try:
            self.state = 339
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51]:
                self.enterOuterAlt(localctx, 1)
                self.state = 330
                self.match(EnglishLangParser.LBRACE)
                self.state = 332 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 331
                    self.loopStatements()
                    self.state = 334 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815294248) != 0) or _la==70):
                        break

                self.state = 336
                self.match(EnglishLangParser.RBRACE)
                pass
            elif token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                self.enterOuterAlt(localctx, 2)
                self.state = 338
                self.statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileLoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(EnglishLangParser.WHILE, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def statement(self):
            return self.getTypedRuleContext(EnglishLangParser.StatementContext,0)


        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.LoopStatementsContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_whileLoop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileLoop" ):
                listener.enterWhileLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileLoop" ):
                listener.exitWhileLoop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileLoop" ):
                return visitor.visitWhileLoop(self)
            else:
                return visitor.visitChildren(self)




    def whileLoop(self):

        localctx = EnglishLangParser.WhileLoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_whileLoop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 341
            self.match(EnglishLangParser.WHILE)
            self.state = 342
            self.match(EnglishLangParser.LPAREN)
            self.state = 343
            self.boolExpression(0)
            self.state = 344
            self.match(EnglishLangParser.RPAREN)
            self.state = 354
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51]:
                self.state = 345
                self.match(EnglishLangParser.LBRACE)
                self.state = 347 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 346
                    self.loopStatements()
                    self.state = 349 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815294248) != 0) or _la==70):
                        break

                self.state = 351
                self.match(EnglishLangParser.RBRACE)
                pass
            elif token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                self.state = 353
                self.statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DisplayStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISPLAY(self):
            return self.getToken(EnglishLangParser.DISPLAY, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_displayStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDisplayStatement" ):
                listener.enterDisplayStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDisplayStatement" ):
                listener.exitDisplayStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisplayStatement" ):
                return visitor.visitDisplayStatement(self)
            else:
                return visitor.visitChildren(self)




    def displayStatement(self):

        localctx = EnglishLangParser.DisplayStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_displayStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 356
            self.match(EnglishLangParser.DISPLAY)
            self.state = 357
            self.expression()
            self.state = 362
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==45:
                self.state = 358
                self.match(EnglishLangParser.COMMA)
                self.state = 359
                self.expression()
                self.state = 364
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock" ):
                listener.enterBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock" ):
                listener.exitBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock" ):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)




    def block(self):

        localctx = EnglishLangParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 365
            self.match(EnglishLangParser.LBRACE)
            self.state = 367 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 366
                self.statement()
                self.state = 369 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1084776) != 0) or _la==70):
                    break

            self.state = 371
            self.match(EnglishLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self):
            return self.getTypedRuleContext(EnglishLangParser.TermContext,0)


        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def PLUS(self):
            return self.getToken(EnglishLangParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(EnglishLangParser.MINUS, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_numExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumExpression" ):
                listener.enterNumExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumExpression" ):
                listener.exitNumExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumExpression" ):
                return visitor.visitNumExpression(self)
            else:
                return visitor.visitChildren(self)



    def numExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = EnglishLangParser.NumExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 58
        self.enterRecursionRule(localctx, 58, self.RULE_numExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 374
            self.term(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 381
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,41,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = EnglishLangParser.NumExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_numExpression)
                    self.state = 376
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 377
                    _la = self._input.LA(1)
                    if not(_la==24 or _la==25):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 378
                    self.term(0) 
                self.state = 383
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,41,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self):
            return self.getTypedRuleContext(EnglishLangParser.FactorContext,0)


        def term(self):
            return self.getTypedRuleContext(EnglishLangParser.TermContext,0)


        def MULTIPLY(self):
            return self.getToken(EnglishLangParser.MULTIPLY, 0)

        def DIVIDED_BY(self):
            return self.getToken(EnglishLangParser.DIVIDED_BY, 0)

        def MODULO(self):
            return self.getToken(EnglishLangParser.MODULO, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm" ):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)



    def term(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = EnglishLangParser.TermContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 60
        self.enterRecursionRule(localctx, 60, self.RULE_term, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 385
            self.factor()
            self._ctx.stop = self._input.LT(-1)
            self.state = 392
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,42,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = EnglishLangParser.TermContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_term)
                    self.state = 387
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 388
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 469762048) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 389
                    self.factor() 
                self.state = 394
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,42,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class FactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionCall(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionCallContext,0)


        def NUMBER(self):
            return self.getToken(EnglishLangParser.NUMBER, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def STRING(self):
            return self.getToken(EnglishLangParser.STRING, 0)

        def operation(self):
            return self.getTypedRuleContext(EnglishLangParser.OperationContext,0)


        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_factor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactor" ):
                listener.enterFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactor" ):
                listener.exitFactor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactor" ):
                return visitor.visitFactor(self)
            else:
                return visitor.visitChildren(self)




    def factor(self):

        localctx = EnglishLangParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_factor)
        try:
            self.state = 404
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 395
                self.functionCall()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 396
                self.match(EnglishLangParser.NUMBER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 397
                self.match(EnglishLangParser.IDENTIFIER)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 398
                self.match(EnglishLangParser.STRING)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 399
                self.operation()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 400
                self.match(EnglishLangParser.LPAREN)
                self.state = 401
                self.numExpression(0)
                self.state = 402
                self.match(EnglishLangParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def INCREMENT(self):
            return self.getToken(EnglishLangParser.INCREMENT, 0)

        def DECREMENT(self):
            return self.getToken(EnglishLangParser.DECREMENT, 0)

        def functionCall(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionCallContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_operation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperation" ):
                listener.enterOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperation" ):
                listener.exitOperation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperation" ):
                return visitor.visitOperation(self)
            else:
                return visitor.visitChildren(self)




    def operation(self):

        localctx = EnglishLangParser.OperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_operation)
        self._la = 0 # Token type
        try:
            self.state = 409
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 406
                self.match(EnglishLangParser.IDENTIFIER)
                self.state = 407
                _la = self._input.LA(1)
                if not(_la==36 or _la==37):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 408
                self.functionCall()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReassignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def SEMICOLON(self):
            return self.getToken(EnglishLangParser.SEMICOLON, 0)

        def SUBTRACT_FROM(self):
            return self.getToken(EnglishLangParser.SUBTRACT_FROM, 0)

        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def DIVIDE_FROM(self):
            return self.getToken(EnglishLangParser.DIVIDE_FROM, 0)

        def TIMES(self):
            return self.getToken(EnglishLangParser.TIMES, 0)

        def ADD_TO(self):
            return self.getToken(EnglishLangParser.ADD_TO, 0)

        def STRING(self):
            return self.getToken(EnglishLangParser.STRING, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_reassignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReassignment" ):
                listener.enterReassignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReassignment" ):
                listener.exitReassignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReassignment" ):
                return visitor.visitReassignment(self)
            else:
                return visitor.visitChildren(self)




    def reassignment(self):

        localctx = EnglishLangParser.ReassignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_reassignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 411
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 424
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [34]:
                self.state = 416
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
                if la_ == 1:
                    self.state = 412
                    self.match(EnglishLangParser.ADD_TO)
                    self.state = 413
                    self.match(EnglishLangParser.STRING)
                    pass

                elif la_ == 2:
                    self.state = 414
                    self.match(EnglishLangParser.ADD_TO)
                    self.state = 415
                    self.numExpression(0)
                    pass


                pass
            elif token in [35]:
                self.state = 418
                self.match(EnglishLangParser.SUBTRACT_FROM)
                self.state = 419
                self.numExpression(0)
                pass
            elif token in [39]:
                self.state = 420
                self.match(EnglishLangParser.DIVIDE_FROM)
                self.state = 421
                self.numExpression(0)
                pass
            elif token in [38]:
                self.state = 422
                self.match(EnglishLangParser.TIMES)
                self.state = 423
                self.numExpression(0)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 426
            self.match(EnglishLangParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return EnglishLangParser.RULE_boolExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class StringComparisonContext(BoolExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def stringExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StringExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StringExpressionContext,i)

        def EQUALS(self):
            return self.getToken(EnglishLangParser.EQUALS, 0)
        def NOT_EQUALS(self):
            return self.getToken(EnglishLangParser.NOT_EQUALS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringComparison" ):
                listener.enterStringComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringComparison" ):
                listener.exitStringComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringComparison" ):
                return visitor.visitStringComparison(self)
            else:
                return visitor.visitChildren(self)


    class FalseLiteralContext(BoolExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FALSE_VALUE(self):
            return self.getToken(EnglishLangParser.FALSE_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFalseLiteral" ):
                listener.enterFalseLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFalseLiteral" ):
                listener.exitFalseLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFalseLiteral" ):
                return visitor.visitFalseLiteral(self)
            else:
                return visitor.visitChildren(self)


    class LogicBinaryContext(BoolExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,i)

        def AND(self):
            return self.getToken(EnglishLangParser.AND, 0)
        def OR(self):
            return self.getToken(EnglishLangParser.OR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicBinary" ):
                listener.enterLogicBinary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicBinary" ):
                listener.exitLogicBinary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicBinary" ):
                return visitor.visitLogicBinary(self)
            else:
                return visitor.visitChildren(self)


    class NumComparisonContext(BoolExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def numExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.NumExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,i)

        def comparisonOp(self):
            return self.getTypedRuleContext(EnglishLangParser.ComparisonOpContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumComparison" ):
                listener.enterNumComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumComparison" ):
                listener.exitNumComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumComparison" ):
                return visitor.visitNumComparison(self)
            else:
                return visitor.visitChildren(self)


    class LogicParenContext(BoolExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)
        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)
        def NOT(self):
            return self.getToken(EnglishLangParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicParen" ):
                listener.enterLogicParen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicParen" ):
                listener.exitLogicParen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicParen" ):
                return visitor.visitLogicParen(self)
            else:
                return visitor.visitChildren(self)


    class TrueLiteralContext(BoolExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRUE_VALUE(self):
            return self.getToken(EnglishLangParser.TRUE_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrueLiteral" ):
                listener.enterTrueLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrueLiteral" ):
                listener.exitTrueLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrueLiteral" ):
                return visitor.visitTrueLiteral(self)
            else:
                return visitor.visitChildren(self)


    class LogicIdentifierContext(BoolExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)
        def NOT(self):
            return self.getToken(EnglishLangParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicIdentifier" ):
                listener.enterLogicIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicIdentifier" ):
                listener.exitLogicIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicIdentifier" ):
                return visitor.visitLogicIdentifier(self)
            else:
                return visitor.visitChildren(self)


    class MatrixComparisonContext(BoolExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def matrixExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.MatrixExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.MatrixExpressionContext,i)

        def EQUALS(self):
            return self.getToken(EnglishLangParser.EQUALS, 0)
        def NOT_EQUALS(self):
            return self.getToken(EnglishLangParser.NOT_EQUALS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixComparison" ):
                listener.enterMatrixComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixComparison" ):
                listener.exitMatrixComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixComparison" ):
                return visitor.visitMatrixComparison(self)
            else:
                return visitor.visitChildren(self)



    def boolExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = EnglishLangParser.BoolExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 68
        self.enterRecursionRule(localctx, 68, self.RULE_boolExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 454
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                localctx = EnglishLangParser.NumComparisonContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 429
                self.numExpression(0)
                self.state = 430
                self.comparisonOp()
                self.state = 431
                self.numExpression(0)
                pass

            elif la_ == 2:
                localctx = EnglishLangParser.StringComparisonContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 433
                self.stringExpression()
                self.state = 434
                _la = self._input.LA(1)
                if not(_la==29 or _la==40):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 435
                self.stringExpression()
                pass

            elif la_ == 3:
                localctx = EnglishLangParser.MatrixComparisonContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 437
                self.matrixExpression()
                self.state = 438
                _la = self._input.LA(1)
                if not(_la==29 or _la==40):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 439
                self.matrixExpression()
                pass

            elif la_ == 4:
                localctx = EnglishLangParser.LogicParenContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 442
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==43:
                    self.state = 441
                    self.match(EnglishLangParser.NOT)


                self.state = 444
                self.match(EnglishLangParser.LPAREN)
                self.state = 445
                self.boolExpression(0)
                self.state = 446
                self.match(EnglishLangParser.RPAREN)
                pass

            elif la_ == 5:
                localctx = EnglishLangParser.TrueLiteralContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 448
                self.match(EnglishLangParser.TRUE_VALUE)
                pass

            elif la_ == 6:
                localctx = EnglishLangParser.FalseLiteralContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 449
                self.match(EnglishLangParser.FALSE_VALUE)
                pass

            elif la_ == 7:
                localctx = EnglishLangParser.LogicIdentifierContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 451
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==43:
                    self.state = 450
                    self.match(EnglishLangParser.NOT)


                self.state = 453
                self.match(EnglishLangParser.IDENTIFIER)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 461
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,50,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = EnglishLangParser.LogicBinaryContext(self, EnglishLangParser.BoolExpressionContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_boolExpression)
                    self.state = 456
                    if not self.precpred(self._ctx, 5):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                    self.state = 457
                    _la = self._input.LA(1)
                    if not(_la==41 or _la==42):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 458
                    self.boolExpression(6) 
                self.state = 463
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,50,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ComparisonOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUALS(self):
            return self.getToken(EnglishLangParser.EQUALS, 0)

        def NOT_EQUALS(self):
            return self.getToken(EnglishLangParser.NOT_EQUALS, 0)

        def GREATER_THAN(self):
            return self.getToken(EnglishLangParser.GREATER_THAN, 0)

        def LESS_THAN(self):
            return self.getToken(EnglishLangParser.LESS_THAN, 0)

        def GREATER_EQUAL(self):
            return self.getToken(EnglishLangParser.GREATER_EQUAL, 0)

        def LESS_EQUAL(self):
            return self.getToken(EnglishLangParser.LESS_EQUAL, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_comparisonOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOp" ):
                listener.enterComparisonOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOp" ):
                listener.exitComparisonOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOp" ):
                return visitor.visitComparisonOp(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOp(self):

        localctx = EnglishLangParser.ComparisonOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_comparisonOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 464
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1116154626048) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[29] = self.numExpression_sempred
        self._predicates[30] = self.term_sempred
        self._predicates[34] = self.boolExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def numExpression_sempred(self, localctx:NumExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def term_sempred(self, localctx:TermContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 2)
         

    def boolExpression_sempred(self, localctx:BoolExpressionContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 5)
         




