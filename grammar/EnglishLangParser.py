# Generated from EnglishLangParser.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,72,439,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,1,0,1,0,4,0,67,
        8,0,11,0,12,0,68,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        3,1,83,8,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,93,8,2,1,3,1,3,1,
        3,1,3,1,3,1,3,1,4,3,4,102,8,4,1,4,1,4,3,4,106,8,4,1,5,1,5,3,5,110,
        8,5,1,6,1,6,1,6,1,6,5,6,116,8,6,10,6,12,6,119,9,6,1,6,1,6,1,7,1,
        7,1,7,5,7,126,8,7,10,7,12,7,129,9,7,1,8,1,8,1,8,3,8,134,8,8,1,9,
        1,9,1,9,5,9,139,8,9,10,9,12,9,142,9,9,1,10,1,10,1,10,1,10,1,10,1,
        10,1,10,3,10,151,8,10,1,11,1,11,1,12,1,12,1,12,1,12,3,12,159,8,12,
        1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,13,1,13,1,13,5,13,171,8,13,
        10,13,12,13,174,9,13,3,13,176,8,13,1,13,3,13,179,8,13,1,14,1,14,
        1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,3,14,193,8,14,
        1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,3,16,204,8,16,1,16,
        1,16,1,16,1,16,1,16,1,16,3,16,212,8,16,5,16,214,8,16,10,16,12,16,
        217,9,16,1,16,1,16,1,16,3,16,222,8,16,3,16,224,8,16,1,17,1,17,1,
        17,1,17,1,17,1,17,4,17,232,8,17,11,17,12,17,233,1,17,1,17,1,17,3,
        17,239,8,17,1,17,1,17,1,17,1,17,1,17,1,17,4,17,247,8,17,11,17,12,
        17,248,1,17,1,17,1,17,3,17,254,8,17,5,17,256,8,17,10,17,12,17,259,
        9,17,1,17,1,17,1,17,4,17,264,8,17,11,17,12,17,265,1,17,1,17,1,17,
        3,17,271,8,17,3,17,273,8,17,1,18,1,18,3,18,277,8,18,1,19,1,19,1,
        19,1,19,3,19,283,8,19,1,19,1,19,1,19,1,19,1,19,1,19,3,19,291,8,19,
        1,19,1,19,1,19,4,19,296,8,19,11,19,12,19,297,1,19,1,19,1,19,3,19,
        303,8,19,1,20,1,20,1,20,1,20,1,20,1,20,4,20,311,8,20,11,20,12,20,
        312,1,20,1,20,1,20,3,20,318,8,20,1,21,1,21,1,21,1,21,5,21,324,8,
        21,10,21,12,21,327,9,21,1,22,1,22,1,22,5,22,332,8,22,10,22,12,22,
        335,9,22,1,23,1,23,1,23,1,24,1,24,4,24,342,8,24,11,24,12,24,343,
        1,24,1,24,1,25,1,25,1,25,1,25,1,25,1,25,5,25,354,8,25,10,25,12,25,
        357,9,25,1,26,1,26,1,26,1,26,1,26,1,26,5,26,365,8,26,10,26,12,26,
        368,9,26,1,27,1,27,1,27,1,27,1,27,1,27,1,27,3,27,377,8,27,1,28,1,
        28,1,28,3,28,382,8,28,1,29,1,29,1,29,1,29,1,29,3,29,389,8,29,1,29,
        1,29,1,29,1,29,1,29,1,29,3,29,397,8,29,1,29,1,29,1,30,1,30,1,30,
        1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,3,30,415,
        8,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,3,30,424,8,30,1,30,3,30,
        427,8,30,1,30,1,30,1,30,5,30,432,8,30,10,30,12,30,435,9,30,1,31,
        1,31,1,31,0,3,50,52,60,32,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,
        30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,0,9,2,0,56,56,
        70,70,1,0,57,61,1,0,66,69,1,0,24,25,1,0,26,28,1,0,36,37,2,0,29,29,
        40,40,1,0,41,42,1,0,29,33,486,0,64,1,0,0,0,2,82,1,0,0,0,4,92,1,0,
        0,0,6,94,1,0,0,0,8,101,1,0,0,0,10,109,1,0,0,0,12,111,1,0,0,0,14,
        122,1,0,0,0,16,133,1,0,0,0,18,135,1,0,0,0,20,150,1,0,0,0,22,152,
        1,0,0,0,24,154,1,0,0,0,26,178,1,0,0,0,28,192,1,0,0,0,30,194,1,0,
        0,0,32,197,1,0,0,0,34,225,1,0,0,0,36,276,1,0,0,0,38,278,1,0,0,0,
        40,304,1,0,0,0,42,319,1,0,0,0,44,328,1,0,0,0,46,336,1,0,0,0,48,339,
        1,0,0,0,50,347,1,0,0,0,52,358,1,0,0,0,54,376,1,0,0,0,56,381,1,0,
        0,0,58,383,1,0,0,0,60,426,1,0,0,0,62,436,1,0,0,0,64,66,5,1,0,0,65,
        67,3,2,1,0,66,65,1,0,0,0,67,68,1,0,0,0,68,66,1,0,0,0,68,69,1,0,0,
        0,69,70,1,0,0,0,70,71,5,2,0,0,71,1,1,0,0,0,72,83,3,6,3,0,73,83,3,
        58,29,0,74,83,3,24,12,0,75,83,3,26,13,0,76,83,3,42,21,0,77,83,3,
        32,16,0,78,83,3,38,19,0,79,83,3,40,20,0,80,83,3,30,15,0,81,83,3,
        56,28,0,82,72,1,0,0,0,82,73,1,0,0,0,82,74,1,0,0,0,82,75,1,0,0,0,
        82,76,1,0,0,0,82,77,1,0,0,0,82,78,1,0,0,0,82,79,1,0,0,0,82,80,1,
        0,0,0,82,81,1,0,0,0,83,3,1,0,0,0,84,93,3,36,18,0,85,93,3,6,3,0,86,
        93,3,58,29,0,87,93,3,24,12,0,88,93,3,30,15,0,89,93,3,34,17,0,90,
        93,3,48,24,0,91,93,5,19,0,0,92,84,1,0,0,0,92,85,1,0,0,0,92,86,1,
        0,0,0,92,87,1,0,0,0,92,88,1,0,0,0,92,89,1,0,0,0,92,90,1,0,0,0,92,
        91,1,0,0,0,93,5,1,0,0,0,94,95,5,8,0,0,95,96,5,70,0,0,96,97,5,9,0,
        0,97,98,3,20,10,0,98,99,3,22,11,0,99,7,1,0,0,0,100,102,5,22,0,0,
        101,100,1,0,0,0,101,102,1,0,0,0,102,103,1,0,0,0,103,105,3,10,5,0,
        104,106,5,23,0,0,105,104,1,0,0,0,105,106,1,0,0,0,106,9,1,0,0,0,107,
        110,5,70,0,0,108,110,3,12,6,0,109,107,1,0,0,0,109,108,1,0,0,0,110,
        11,1,0,0,0,111,112,5,51,0,0,112,117,3,14,7,0,113,114,5,44,0,0,114,
        116,3,14,7,0,115,113,1,0,0,0,116,119,1,0,0,0,117,115,1,0,0,0,117,
        118,1,0,0,0,118,120,1,0,0,0,119,117,1,0,0,0,120,121,5,52,0,0,121,
        13,1,0,0,0,122,127,3,16,8,0,123,124,5,45,0,0,124,126,3,16,8,0,125,
        123,1,0,0,0,126,129,1,0,0,0,127,125,1,0,0,0,127,128,1,0,0,0,128,
        15,1,0,0,0,129,127,1,0,0,0,130,134,5,55,0,0,131,134,5,70,0,0,132,
        134,3,8,4,0,133,130,1,0,0,0,133,131,1,0,0,0,133,132,1,0,0,0,134,
        17,1,0,0,0,135,140,7,0,0,0,136,137,5,24,0,0,137,139,7,0,0,0,138,
        136,1,0,0,0,139,142,1,0,0,0,140,138,1,0,0,0,140,141,1,0,0,0,141,
        19,1,0,0,0,142,140,1,0,0,0,143,151,3,50,25,0,144,151,3,60,30,0,145,
        151,3,8,4,0,146,151,3,18,9,0,147,151,5,55,0,0,148,151,5,56,0,0,149,
        151,5,70,0,0,150,143,1,0,0,0,150,144,1,0,0,0,150,145,1,0,0,0,150,
        146,1,0,0,0,150,147,1,0,0,0,150,148,1,0,0,0,150,149,1,0,0,0,151,
        21,1,0,0,0,152,153,7,1,0,0,153,23,1,0,0,0,154,155,5,3,0,0,155,156,
        5,70,0,0,156,158,5,53,0,0,157,159,3,44,22,0,158,157,1,0,0,0,158,
        159,1,0,0,0,159,160,1,0,0,0,160,161,5,54,0,0,161,162,3,48,24,0,162,
        163,5,4,0,0,163,25,1,0,0,0,164,179,3,28,14,0,165,166,5,70,0,0,166,
        175,5,53,0,0,167,172,5,70,0,0,168,169,5,45,0,0,169,171,5,70,0,0,
        170,168,1,0,0,0,171,174,1,0,0,0,172,170,1,0,0,0,172,173,1,0,0,0,
        173,176,1,0,0,0,174,172,1,0,0,0,175,167,1,0,0,0,175,176,1,0,0,0,
        176,177,1,0,0,0,177,179,5,54,0,0,178,164,1,0,0,0,178,165,1,0,0,0,
        179,27,1,0,0,0,180,181,5,65,0,0,181,182,5,53,0,0,182,183,3,50,25,
        0,183,184,5,45,0,0,184,185,3,50,25,0,185,186,5,54,0,0,186,193,1,
        0,0,0,187,188,7,2,0,0,188,189,5,53,0,0,189,190,3,50,25,0,190,191,
        5,54,0,0,191,193,1,0,0,0,192,180,1,0,0,0,192,187,1,0,0,0,193,29,
        1,0,0,0,194,195,5,5,0,0,195,196,3,20,10,0,196,31,1,0,0,0,197,198,
        5,11,0,0,198,199,5,53,0,0,199,200,3,60,30,0,200,203,5,54,0,0,201,
        204,3,2,1,0,202,204,3,48,24,0,203,201,1,0,0,0,203,202,1,0,0,0,204,
        215,1,0,0,0,205,206,5,12,0,0,206,207,5,53,0,0,207,208,3,60,30,0,
        208,211,5,54,0,0,209,212,3,2,1,0,210,212,3,48,24,0,211,209,1,0,0,
        0,211,210,1,0,0,0,212,214,1,0,0,0,213,205,1,0,0,0,214,217,1,0,0,
        0,215,213,1,0,0,0,215,216,1,0,0,0,216,223,1,0,0,0,217,215,1,0,0,
        0,218,221,5,13,0,0,219,222,3,2,1,0,220,222,3,48,24,0,221,219,1,0,
        0,0,221,220,1,0,0,0,222,224,1,0,0,0,223,218,1,0,0,0,223,224,1,0,
        0,0,224,33,1,0,0,0,225,226,5,11,0,0,226,227,5,53,0,0,227,228,3,60,
        30,0,228,238,5,54,0,0,229,231,5,51,0,0,230,232,3,4,2,0,231,230,1,
        0,0,0,232,233,1,0,0,0,233,231,1,0,0,0,233,234,1,0,0,0,234,235,1,
        0,0,0,235,236,5,52,0,0,236,239,1,0,0,0,237,239,3,2,1,0,238,229,1,
        0,0,0,238,237,1,0,0,0,239,257,1,0,0,0,240,241,5,12,0,0,241,242,5,
        53,0,0,242,243,3,60,30,0,243,253,5,54,0,0,244,246,5,51,0,0,245,247,
        3,4,2,0,246,245,1,0,0,0,247,248,1,0,0,0,248,246,1,0,0,0,248,249,
        1,0,0,0,249,250,1,0,0,0,250,251,5,52,0,0,251,254,1,0,0,0,252,254,
        3,2,1,0,253,244,1,0,0,0,253,252,1,0,0,0,254,256,1,0,0,0,255,240,
        1,0,0,0,256,259,1,0,0,0,257,255,1,0,0,0,257,258,1,0,0,0,258,272,
        1,0,0,0,259,257,1,0,0,0,260,270,5,13,0,0,261,263,5,51,0,0,262,264,
        3,4,2,0,263,262,1,0,0,0,264,265,1,0,0,0,265,263,1,0,0,0,265,266,
        1,0,0,0,266,267,1,0,0,0,267,268,5,52,0,0,268,271,1,0,0,0,269,271,
        3,2,1,0,270,261,1,0,0,0,270,269,1,0,0,0,271,273,1,0,0,0,272,260,
        1,0,0,0,272,273,1,0,0,0,273,35,1,0,0,0,274,277,3,38,19,0,275,277,
        3,40,20,0,276,274,1,0,0,0,276,275,1,0,0,0,277,37,1,0,0,0,278,279,
        5,15,0,0,279,282,5,53,0,0,280,283,5,70,0,0,281,283,3,6,3,0,282,280,
        1,0,0,0,282,281,1,0,0,0,282,283,1,0,0,0,283,284,1,0,0,0,284,285,
        5,44,0,0,285,286,3,60,30,0,286,290,5,44,0,0,287,291,3,6,3,0,288,
        291,3,58,29,0,289,291,3,56,28,0,290,287,1,0,0,0,290,288,1,0,0,0,
        290,289,1,0,0,0,291,292,1,0,0,0,292,302,5,54,0,0,293,295,5,51,0,
        0,294,296,3,4,2,0,295,294,1,0,0,0,296,297,1,0,0,0,297,295,1,0,0,
        0,297,298,1,0,0,0,298,299,1,0,0,0,299,300,5,52,0,0,300,303,1,0,0,
        0,301,303,3,2,1,0,302,293,1,0,0,0,302,301,1,0,0,0,303,39,1,0,0,0,
        304,305,5,20,0,0,305,306,5,53,0,0,306,307,3,60,30,0,307,317,5,54,
        0,0,308,310,5,51,0,0,309,311,3,4,2,0,310,309,1,0,0,0,311,312,1,0,
        0,0,312,310,1,0,0,0,312,313,1,0,0,0,313,314,1,0,0,0,314,315,5,52,
        0,0,315,318,1,0,0,0,316,318,3,2,1,0,317,308,1,0,0,0,317,316,1,0,
        0,0,318,41,1,0,0,0,319,320,5,10,0,0,320,325,3,20,10,0,321,322,5,
        45,0,0,322,324,3,20,10,0,323,321,1,0,0,0,324,327,1,0,0,0,325,323,
        1,0,0,0,325,326,1,0,0,0,326,43,1,0,0,0,327,325,1,0,0,0,328,333,3,
        46,23,0,329,330,5,45,0,0,330,332,3,46,23,0,331,329,1,0,0,0,332,335,
        1,0,0,0,333,331,1,0,0,0,333,334,1,0,0,0,334,45,1,0,0,0,335,333,1,
        0,0,0,336,337,5,70,0,0,337,338,3,22,11,0,338,47,1,0,0,0,339,341,
        5,51,0,0,340,342,3,2,1,0,341,340,1,0,0,0,342,343,1,0,0,0,343,341,
        1,0,0,0,343,344,1,0,0,0,344,345,1,0,0,0,345,346,5,52,0,0,346,49,
        1,0,0,0,347,348,6,25,-1,0,348,349,3,52,26,0,349,355,1,0,0,0,350,
        351,10,2,0,0,351,352,7,3,0,0,352,354,3,52,26,0,353,350,1,0,0,0,354,
        357,1,0,0,0,355,353,1,0,0,0,355,356,1,0,0,0,356,51,1,0,0,0,357,355,
        1,0,0,0,358,359,6,26,-1,0,359,360,3,54,27,0,360,366,1,0,0,0,361,
        362,10,2,0,0,362,363,7,4,0,0,363,365,3,54,27,0,364,361,1,0,0,0,365,
        368,1,0,0,0,366,364,1,0,0,0,366,367,1,0,0,0,367,53,1,0,0,0,368,366,
        1,0,0,0,369,377,5,55,0,0,370,377,5,70,0,0,371,377,3,56,28,0,372,
        373,5,53,0,0,373,374,3,50,25,0,374,375,5,54,0,0,375,377,1,0,0,0,
        376,369,1,0,0,0,376,370,1,0,0,0,376,371,1,0,0,0,376,372,1,0,0,0,
        377,55,1,0,0,0,378,379,5,70,0,0,379,382,7,5,0,0,380,382,3,26,13,
        0,381,378,1,0,0,0,381,380,1,0,0,0,382,57,1,0,0,0,383,396,5,70,0,
        0,384,385,5,34,0,0,385,389,5,56,0,0,386,387,5,34,0,0,387,389,3,50,
        25,0,388,384,1,0,0,0,388,386,1,0,0,0,389,397,1,0,0,0,390,391,5,35,
        0,0,391,397,3,50,25,0,392,393,5,39,0,0,393,397,3,50,25,0,394,395,
        5,38,0,0,395,397,3,50,25,0,396,388,1,0,0,0,396,390,1,0,0,0,396,392,
        1,0,0,0,396,394,1,0,0,0,397,398,1,0,0,0,398,399,5,44,0,0,399,59,
        1,0,0,0,400,401,6,30,-1,0,401,402,3,50,25,0,402,403,3,62,31,0,403,
        404,3,50,25,0,404,427,1,0,0,0,405,406,3,18,9,0,406,407,7,6,0,0,407,
        408,3,18,9,0,408,427,1,0,0,0,409,410,3,8,4,0,410,411,7,6,0,0,411,
        412,3,8,4,0,412,427,1,0,0,0,413,415,5,43,0,0,414,413,1,0,0,0,414,
        415,1,0,0,0,415,416,1,0,0,0,416,417,5,53,0,0,417,418,3,60,30,0,418,
        419,5,54,0,0,419,427,1,0,0,0,420,427,5,63,0,0,421,427,5,64,0,0,422,
        424,5,43,0,0,423,422,1,0,0,0,423,424,1,0,0,0,424,425,1,0,0,0,425,
        427,5,70,0,0,426,400,1,0,0,0,426,405,1,0,0,0,426,409,1,0,0,0,426,
        414,1,0,0,0,426,420,1,0,0,0,426,421,1,0,0,0,426,423,1,0,0,0,427,
        433,1,0,0,0,428,429,10,5,0,0,429,430,7,7,0,0,430,432,3,60,30,6,431,
        428,1,0,0,0,432,435,1,0,0,0,433,431,1,0,0,0,433,434,1,0,0,0,434,
        61,1,0,0,0,435,433,1,0,0,0,436,437,7,8,0,0,437,63,1,0,0,0,49,68,
        82,92,101,105,109,117,127,133,140,150,158,172,175,178,192,203,211,
        215,221,223,233,238,248,253,257,265,270,272,276,282,290,297,302,
        312,317,325,333,343,355,366,376,381,388,396,414,423,426,433
    ]

class EnglishLangParser ( Parser ):

    grammarFileName = "EnglishLangParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'Start Program'", "'End Program'", "'Define Function'", 
                     "'End Function'", "'Return'", "'Call'", "'with'", "'Set'", 
                     "'to'", "'Display'", "'If'", "'Else If'", "'Else'", 
                     "'End If'", "'For'", "'from'", "'in'", "'End For'", 
                     "'break'", "'While'", "'End While'", "'invert'", "''T'", 
                     "'+'", "'-'", "'*'", "'/'", "'%'", "'=='", "'>'", "'<'", 
                     "'>='", "'<='", "'+='", "'-='", "'++'", "'--'", "'*='", 
                     "'/='", "'!='", "'&&'", "'||'", "'!'", "';'", "','", 
                     "':'", "'.'", "'\"'", "'['", "']'", "'{'", "'}'", "'('", 
                     "')'", "<INVALID>", "<INVALID>", "'int'", "'string'", 
                     "'bool'", "'float'", "'matrix'", "'void'", "'true'", 
                     "'false'", "'pow'", "'sin'", "'cos'", "'tan'", "'ctan'" ]

    symbolicNames = [ "<INVALID>", "START_PROGRAM", "END_PROGRAM", "DEFINE_FUNCTION", 
                      "END_FUNCTION", "RETURN", "CALL", "WITH", "SET", "TO", 
                      "DISPLAY", "IF", "ELSE_IF", "ELSE", "END_IF", "FOR", 
                      "FROM", "IN", "END_FOR", "BREAK", "WHILE", "END_WHILE", 
                      "INVERT_MATRIX", "TRANSPOSITION", "PLUS", "MINUS", 
                      "MULTIPLY", "DIVIDED_BY", "MODULO", "EQUALS", "GREATER_THAN", 
                      "LESS_THAN", "GREATER_EQUAL", "LESS_EQUAL", "ADD_TO", 
                      "SUBTRACT_FROM", "INCREMENT", "DECREMENT", "TIMES", 
                      "DIVIDE_FROM", "NOT_EQUALS", "AND", "OR", "NOT", "SEMICOLON", 
                      "COMMA", "COLON", "DOT", "QUOTE", "LBRACK", "RBRACK", 
                      "LBRACE", "RBRACE", "LPAREN", "RPAREN", "NUMBER", 
                      "STRING", "TYPE_INT", "TYPE_STRING", "TYPE_BOOL", 
                      "TYPE_FLOAT", "TYPE_MATRIX", "TYPE_VOID", "TRUE_VALUE", 
                      "FALSE_VALUE", "POWER_FUNC", "SIN_FUNC", "COS_FUNC", 
                      "TAN_FUNC", "CTAN_FUNC", "IDENTIFIER", "WS", "COMMENT" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_loopStatements = 2
    RULE_variableDeclaration = 3
    RULE_matrixExpression = 4
    RULE_matrixAtom = 5
    RULE_matrixConstruction = 6
    RULE_row = 7
    RULE_value = 8
    RULE_stringExpression = 9
    RULE_expression = 10
    RULE_typeAnnotation = 11
    RULE_functionDeclaration = 12
    RULE_functionCall = 13
    RULE_builtInFunctions = 14
    RULE_returnStatement = 15
    RULE_ifStatement = 16
    RULE_loopIfStatement = 17
    RULE_loopStatement = 18
    RULE_forLoop = 19
    RULE_whileLoop = 20
    RULE_displayStatement = 21
    RULE_parameter = 22
    RULE_typedParameter = 23
    RULE_block = 24
    RULE_numExpression = 25
    RULE_term = 26
    RULE_factor = 27
    RULE_operation = 28
    RULE_reassignment = 29
    RULE_boolExpression = 30
    RULE_comparisonOp = 31

    ruleNames =  [ "program", "statement", "loopStatements", "variableDeclaration", 
                   "matrixExpression", "matrixAtom", "matrixConstruction", 
                   "row", "value", "stringExpression", "expression", "typeAnnotation", 
                   "functionDeclaration", "functionCall", "builtInFunctions", 
                   "returnStatement", "ifStatement", "loopIfStatement", 
                   "loopStatement", "forLoop", "whileLoop", "displayStatement", 
                   "parameter", "typedParameter", "block", "numExpression", 
                   "term", "factor", "operation", "reassignment", "boolExpression", 
                   "comparisonOp" ]

    EOF = Token.EOF
    START_PROGRAM=1
    END_PROGRAM=2
    DEFINE_FUNCTION=3
    END_FUNCTION=4
    RETURN=5
    CALL=6
    WITH=7
    SET=8
    TO=9
    DISPLAY=10
    IF=11
    ELSE_IF=12
    ELSE=13
    END_IF=14
    FOR=15
    FROM=16
    IN=17
    END_FOR=18
    BREAK=19
    WHILE=20
    END_WHILE=21
    INVERT_MATRIX=22
    TRANSPOSITION=23
    PLUS=24
    MINUS=25
    MULTIPLY=26
    DIVIDED_BY=27
    MODULO=28
    EQUALS=29
    GREATER_THAN=30
    LESS_THAN=31
    GREATER_EQUAL=32
    LESS_EQUAL=33
    ADD_TO=34
    SUBTRACT_FROM=35
    INCREMENT=36
    DECREMENT=37
    TIMES=38
    DIVIDE_FROM=39
    NOT_EQUALS=40
    AND=41
    OR=42
    NOT=43
    SEMICOLON=44
    COMMA=45
    COLON=46
    DOT=47
    QUOTE=48
    LBRACK=49
    RBRACK=50
    LBRACE=51
    RBRACE=52
    LPAREN=53
    RPAREN=54
    NUMBER=55
    STRING=56
    TYPE_INT=57
    TYPE_STRING=58
    TYPE_BOOL=59
    TYPE_FLOAT=60
    TYPE_MATRIX=61
    TYPE_VOID=62
    TRUE_VALUE=63
    FALSE_VALUE=64
    POWER_FUNC=65
    SIN_FUNC=66
    COS_FUNC=67
    TAN_FUNC=68
    CTAN_FUNC=69
    IDENTIFIER=70
    WS=71
    COMMENT=72

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def START_PROGRAM(self):
            return self.getToken(EnglishLangParser.START_PROGRAM, 0)

        def END_PROGRAM(self):
            return self.getToken(EnglishLangParser.END_PROGRAM, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = EnglishLangParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 64
            self.match(EnglishLangParser.START_PROGRAM)
            self.state = 66 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 65
                self.statement()
                self.state = 68 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1084712) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 63) != 0)):
                    break

            self.state = 70
            self.match(EnglishLangParser.END_PROGRAM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(EnglishLangParser.ReassignmentContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionDeclarationContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionCallContext,0)


        def displayStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.DisplayStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.IfStatementContext,0)


        def forLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.ForLoopContext,0)


        def whileLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.WhileLoopContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.ReturnStatementContext,0)


        def operation(self):
            return self.getTypedRuleContext(EnglishLangParser.OperationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = EnglishLangParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 82
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 72
                self.variableDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 73
                self.reassignment()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 74
                self.functionDeclaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 75
                self.functionCall()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 76
                self.displayStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 77
                self.ifStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 78
                self.forLoop()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 79
                self.whileLoop()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 80
                self.returnStatement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 81
                self.operation()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopStatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.LoopStatementContext,0)


        def variableDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(EnglishLangParser.ReassignmentContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionDeclarationContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.ReturnStatementContext,0)


        def loopIfStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.LoopIfStatementContext,0)


        def block(self):
            return self.getTypedRuleContext(EnglishLangParser.BlockContext,0)


        def BREAK(self):
            return self.getToken(EnglishLangParser.BREAK, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_loopStatements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopStatements" ):
                listener.enterLoopStatements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopStatements" ):
                listener.exitLoopStatements(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopStatements" ):
                return visitor.visitLoopStatements(self)
            else:
                return visitor.visitChildren(self)




    def loopStatements(self):

        localctx = EnglishLangParser.LoopStatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_loopStatements)
        try:
            self.state = 92
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [15, 20]:
                self.enterOuterAlt(localctx, 1)
                self.state = 84
                self.loopStatement()
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 2)
                self.state = 85
                self.variableDeclaration()
                pass
            elif token in [70]:
                self.enterOuterAlt(localctx, 3)
                self.state = 86
                self.reassignment()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 4)
                self.state = 87
                self.functionDeclaration()
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 5)
                self.state = 88
                self.returnStatement()
                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 6)
                self.state = 89
                self.loopIfStatement()
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 7)
                self.state = 90
                self.block()
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 8)
                self.state = 91
                self.match(EnglishLangParser.BREAK)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(EnglishLangParser.SET, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def TO(self):
            return self.getToken(EnglishLangParser.TO, 0)

        def expression(self):
            return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,0)


        def typeAnnotation(self):
            return self.getTypedRuleContext(EnglishLangParser.TypeAnnotationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_variableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclaration" ):
                listener.enterVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclaration" ):
                listener.exitVariableDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclaration" ):
                return visitor.visitVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclaration(self):

        localctx = EnglishLangParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_variableDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 94
            self.match(EnglishLangParser.SET)
            self.state = 95
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 96
            self.match(EnglishLangParser.TO)
            self.state = 97
            self.expression()
            self.state = 98
            self.typeAnnotation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def matrixAtom(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixAtomContext,0)


        def INVERT_MATRIX(self):
            return self.getToken(EnglishLangParser.INVERT_MATRIX, 0)

        def TRANSPOSITION(self):
            return self.getToken(EnglishLangParser.TRANSPOSITION, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_matrixExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixExpression" ):
                listener.enterMatrixExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixExpression" ):
                listener.exitMatrixExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixExpression" ):
                return visitor.visitMatrixExpression(self)
            else:
                return visitor.visitChildren(self)




    def matrixExpression(self):

        localctx = EnglishLangParser.MatrixExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_matrixExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 100
                self.match(EnglishLangParser.INVERT_MATRIX)


            self.state = 103
            self.matrixAtom()
            self.state = 105
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.state = 104
                self.match(EnglishLangParser.TRANSPOSITION)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixAtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def matrixConstruction(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixConstructionContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_matrixAtom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixAtom" ):
                listener.enterMatrixAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixAtom" ):
                listener.exitMatrixAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixAtom" ):
                return visitor.visitMatrixAtom(self)
            else:
                return visitor.visitChildren(self)




    def matrixAtom(self):

        localctx = EnglishLangParser.MatrixAtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_matrixAtom)
        try:
            self.state = 109
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [70]:
                self.enterOuterAlt(localctx, 1)
                self.state = 107
                self.match(EnglishLangParser.IDENTIFIER)
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 2)
                self.state = 108
                self.matrixConstruction()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixConstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def row(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.RowContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.RowContext,i)


        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.SEMICOLON)
            else:
                return self.getToken(EnglishLangParser.SEMICOLON, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_matrixConstruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixConstruction" ):
                listener.enterMatrixConstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixConstruction" ):
                listener.exitMatrixConstruction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixConstruction" ):
                return visitor.visitMatrixConstruction(self)
            else:
                return visitor.visitChildren(self)




    def matrixConstruction(self):

        localctx = EnglishLangParser.MatrixConstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_matrixConstruction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            self.match(EnglishLangParser.LBRACE)
            self.state = 112
            self.row()
            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==44:
                self.state = 113
                self.match(EnglishLangParser.SEMICOLON)
                self.state = 114
                self.row()
                self.state = 119
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 120
            self.match(EnglishLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.ValueContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.ValueContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_row

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRow" ):
                listener.enterRow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRow" ):
                listener.exitRow(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRow" ):
                return visitor.visitRow(self)
            else:
                return visitor.visitChildren(self)




    def row(self):

        localctx = EnglishLangParser.RowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_row)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self.value()
            self.state = 127
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==45:
                self.state = 123
                self.match(EnglishLangParser.COMMA)
                self.state = 124
                self.value()
                self.state = 129
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(EnglishLangParser.NUMBER, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def matrixExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixExpressionContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue" ):
                listener.enterValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue" ):
                listener.exitValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValue" ):
                return visitor.visitValue(self)
            else:
                return visitor.visitChildren(self)




    def value(self):

        localctx = EnglishLangParser.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_value)
        try:
            self.state = 133
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 130
                self.match(EnglishLangParser.NUMBER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 131
                self.match(EnglishLangParser.IDENTIFIER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 132
                self.matrixExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.STRING)
            else:
                return self.getToken(EnglishLangParser.STRING, i)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.IDENTIFIER)
            else:
                return self.getToken(EnglishLangParser.IDENTIFIER, i)

        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.PLUS)
            else:
                return self.getToken(EnglishLangParser.PLUS, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_stringExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringExpression" ):
                listener.enterStringExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringExpression" ):
                listener.exitStringExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringExpression" ):
                return visitor.visitStringExpression(self)
            else:
                return visitor.visitChildren(self)




    def stringExpression(self):

        localctx = EnglishLangParser.StringExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_stringExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            _la = self._input.LA(1)
            if not(_la==56 or _la==70):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 140
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 136
                    self.match(EnglishLangParser.PLUS)
                    self.state = 137
                    _la = self._input.LA(1)
                    if not(_la==56 or _la==70):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 142
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)


        def matrixExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixExpressionContext,0)


        def stringExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.StringExpressionContext,0)


        def NUMBER(self):
            return self.getToken(EnglishLangParser.NUMBER, 0)

        def STRING(self):
            return self.getToken(EnglishLangParser.STRING, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = EnglishLangParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_expression)
        try:
            self.state = 150
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 143
                self.numExpression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 144
                self.boolExpression(0)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 145
                self.matrixExpression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 146
                self.stringExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 147
                self.match(EnglishLangParser.NUMBER)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 148
                self.match(EnglishLangParser.STRING)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 149
                self.match(EnglishLangParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeAnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE_STRING(self):
            return self.getToken(EnglishLangParser.TYPE_STRING, 0)

        def TYPE_INT(self):
            return self.getToken(EnglishLangParser.TYPE_INT, 0)

        def TYPE_FLOAT(self):
            return self.getToken(EnglishLangParser.TYPE_FLOAT, 0)

        def TYPE_BOOL(self):
            return self.getToken(EnglishLangParser.TYPE_BOOL, 0)

        def TYPE_MATRIX(self):
            return self.getToken(EnglishLangParser.TYPE_MATRIX, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_typeAnnotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeAnnotation" ):
                listener.enterTypeAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeAnnotation" ):
                listener.exitTypeAnnotation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeAnnotation" ):
                return visitor.visitTypeAnnotation(self)
            else:
                return visitor.visitChildren(self)




    def typeAnnotation(self):

        localctx = EnglishLangParser.TypeAnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_typeAnnotation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 4467570830351532032) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE_FUNCTION(self):
            return self.getToken(EnglishLangParser.DEFINE_FUNCTION, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def block(self):
            return self.getTypedRuleContext(EnglishLangParser.BlockContext,0)


        def END_FUNCTION(self):
            return self.getToken(EnglishLangParser.END_FUNCTION, 0)

        def parameter(self):
            return self.getTypedRuleContext(EnglishLangParser.ParameterContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_functionDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDeclaration" ):
                listener.enterFunctionDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDeclaration" ):
                listener.exitFunctionDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDeclaration" ):
                return visitor.visitFunctionDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def functionDeclaration(self):

        localctx = EnglishLangParser.FunctionDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_functionDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.match(EnglishLangParser.DEFINE_FUNCTION)
            self.state = 155
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 156
            self.match(EnglishLangParser.LPAREN)
            self.state = 158
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==70:
                self.state = 157
                self.parameter()


            self.state = 160
            self.match(EnglishLangParser.RPAREN)
            self.state = 161
            self.block()
            self.state = 162
            self.match(EnglishLangParser.END_FUNCTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def builtInFunctions(self):
            return self.getTypedRuleContext(EnglishLangParser.BuiltInFunctionsContext,0)


        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.IDENTIFIER)
            else:
                return self.getToken(EnglishLangParser.IDENTIFIER, i)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = EnglishLangParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_functionCall)
        self._la = 0 # Token type
        try:
            self.state = 178
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [65, 66, 67, 68, 69]:
                self.enterOuterAlt(localctx, 1)
                self.state = 164
                self.builtInFunctions()
                pass
            elif token in [70]:
                self.enterOuterAlt(localctx, 2)
                self.state = 165
                self.match(EnglishLangParser.IDENTIFIER)
                self.state = 166
                self.match(EnglishLangParser.LPAREN)
                self.state = 175
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==70:
                    self.state = 167
                    self.match(EnglishLangParser.IDENTIFIER)
                    self.state = 172
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==45:
                        self.state = 168
                        self.match(EnglishLangParser.COMMA)
                        self.state = 169
                        self.match(EnglishLangParser.IDENTIFIER)
                        self.state = 174
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 177
                self.match(EnglishLangParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BuiltInFunctionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POWER_FUNC(self):
            return self.getToken(EnglishLangParser.POWER_FUNC, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def numExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.NumExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,i)


        def COMMA(self):
            return self.getToken(EnglishLangParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def SIN_FUNC(self):
            return self.getToken(EnglishLangParser.SIN_FUNC, 0)

        def COS_FUNC(self):
            return self.getToken(EnglishLangParser.COS_FUNC, 0)

        def TAN_FUNC(self):
            return self.getToken(EnglishLangParser.TAN_FUNC, 0)

        def CTAN_FUNC(self):
            return self.getToken(EnglishLangParser.CTAN_FUNC, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_builtInFunctions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBuiltInFunctions" ):
                listener.enterBuiltInFunctions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBuiltInFunctions" ):
                listener.exitBuiltInFunctions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBuiltInFunctions" ):
                return visitor.visitBuiltInFunctions(self)
            else:
                return visitor.visitChildren(self)




    def builtInFunctions(self):

        localctx = EnglishLangParser.BuiltInFunctionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_builtInFunctions)
        self._la = 0 # Token type
        try:
            self.state = 192
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [65]:
                self.enterOuterAlt(localctx, 1)
                self.state = 180
                self.match(EnglishLangParser.POWER_FUNC)
                self.state = 181
                self.match(EnglishLangParser.LPAREN)
                self.state = 182
                self.numExpression(0)
                self.state = 183
                self.match(EnglishLangParser.COMMA)
                self.state = 184
                self.numExpression(0)
                self.state = 185
                self.match(EnglishLangParser.RPAREN)
                pass
            elif token in [66, 67, 68, 69]:
                self.enterOuterAlt(localctx, 2)
                self.state = 187
                _la = self._input.LA(1)
                if not(((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 15) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 188
                self.match(EnglishLangParser.LPAREN)
                self.state = 189
                self.numExpression(0)
                self.state = 190
                self.match(EnglishLangParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(EnglishLangParser.RETURN, 0)

        def expression(self):
            return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_returnStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStatement" ):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)




    def returnStatement(self):

        localctx = EnglishLangParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 194
            self.match(EnglishLangParser.RETURN)
            self.state = 195
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(EnglishLangParser.IF, 0)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.LPAREN)
            else:
                return self.getToken(EnglishLangParser.LPAREN, i)

        def boolExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,i)


        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.RPAREN)
            else:
                return self.getToken(EnglishLangParser.RPAREN, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def block(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BlockContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BlockContext,i)


        def ELSE_IF(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.ELSE_IF)
            else:
                return self.getToken(EnglishLangParser.ELSE_IF, i)

        def ELSE(self):
            return self.getToken(EnglishLangParser.ELSE, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStatement(self):

        localctx = EnglishLangParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_ifStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(EnglishLangParser.IF)
            self.state = 198
            self.match(EnglishLangParser.LPAREN)
            self.state = 199
            self.boolExpression(0)
            self.state = 200
            self.match(EnglishLangParser.RPAREN)
            self.state = 203
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 5, 8, 10, 11, 15, 20, 65, 66, 67, 68, 69, 70]:
                self.state = 201
                self.statement()
                pass
            elif token in [51]:
                self.state = 202
                self.block()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 215
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 205
                    self.match(EnglishLangParser.ELSE_IF)
                    self.state = 206
                    self.match(EnglishLangParser.LPAREN)
                    self.state = 207
                    self.boolExpression(0)
                    self.state = 208
                    self.match(EnglishLangParser.RPAREN)
                    self.state = 211
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [3, 5, 8, 10, 11, 15, 20, 65, 66, 67, 68, 69, 70]:
                        self.state = 209
                        self.statement()
                        pass
                    elif token in [51]:
                        self.state = 210
                        self.block()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 217
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

            self.state = 223
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.state = 218
                self.match(EnglishLangParser.ELSE)
                self.state = 221
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [3, 5, 8, 10, 11, 15, 20, 65, 66, 67, 68, 69, 70]:
                    self.state = 219
                    self.statement()
                    pass
                elif token in [51]:
                    self.state = 220
                    self.block()
                    pass
                else:
                    raise NoViableAltException(self)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopIfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(EnglishLangParser.IF, 0)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.LPAREN)
            else:
                return self.getToken(EnglishLangParser.LPAREN, i)

        def boolExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,i)


        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.RPAREN)
            else:
                return self.getToken(EnglishLangParser.RPAREN, i)

        def LBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.LBRACE)
            else:
                return self.getToken(EnglishLangParser.LBRACE, i)

        def RBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.RBRACE)
            else:
                return self.getToken(EnglishLangParser.RBRACE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def ELSE_IF(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.ELSE_IF)
            else:
                return self.getToken(EnglishLangParser.ELSE_IF, i)

        def ELSE(self):
            return self.getToken(EnglishLangParser.ELSE, 0)

        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.LoopStatementsContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_loopIfStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopIfStatement" ):
                listener.enterLoopIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopIfStatement" ):
                listener.exitLoopIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopIfStatement" ):
                return visitor.visitLoopIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def loopIfStatement(self):

        localctx = EnglishLangParser.LoopIfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_loopIfStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 225
            self.match(EnglishLangParser.IF)
            self.state = 226
            self.match(EnglishLangParser.LPAREN)
            self.state = 227
            self.boolExpression(0)
            self.state = 228
            self.match(EnglishLangParser.RPAREN)
            self.state = 238
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51]:
                self.state = 229
                self.match(EnglishLangParser.LBRACE)
                self.state = 231 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 230
                    self.loopStatements()
                    self.state = 233 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815293224) != 0) or _la==70):
                        break

                self.state = 235
                self.match(EnglishLangParser.RBRACE)
                pass
            elif token in [3, 5, 8, 10, 11, 15, 20, 65, 66, 67, 68, 69, 70]:
                self.state = 237
                self.statement()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 257
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==12:
                self.state = 240
                self.match(EnglishLangParser.ELSE_IF)
                self.state = 241
                self.match(EnglishLangParser.LPAREN)
                self.state = 242
                self.boolExpression(0)
                self.state = 243
                self.match(EnglishLangParser.RPAREN)
                self.state = 253
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [51]:
                    self.state = 244
                    self.match(EnglishLangParser.LBRACE)
                    self.state = 246 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 245
                        self.loopStatements()
                        self.state = 248 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815293224) != 0) or _la==70):
                            break

                    self.state = 250
                    self.match(EnglishLangParser.RBRACE)
                    pass
                elif token in [3, 5, 8, 10, 11, 15, 20, 65, 66, 67, 68, 69, 70]:
                    self.state = 252
                    self.statement()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 259
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 272
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 260
                self.match(EnglishLangParser.ELSE)
                self.state = 270
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [51]:
                    self.state = 261
                    self.match(EnglishLangParser.LBRACE)
                    self.state = 263 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 262
                        self.loopStatements()
                        self.state = 265 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815293224) != 0) or _la==70):
                            break

                    self.state = 267
                    self.match(EnglishLangParser.RBRACE)
                    pass
                elif token in [3, 5, 8, 10, 11, 15, 20, 65, 66, 67, 68, 69, 70]:
                    self.state = 269
                    self.statement()
                    pass
                else:
                    raise NoViableAltException(self)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.ForLoopContext,0)


        def whileLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.WhileLoopContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_loopStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopStatement" ):
                listener.enterLoopStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopStatement" ):
                listener.exitLoopStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopStatement" ):
                return visitor.visitLoopStatement(self)
            else:
                return visitor.visitChildren(self)




    def loopStatement(self):

        localctx = EnglishLangParser.LoopStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_loopStatement)
        try:
            self.state = 276
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [15]:
                self.enterOuterAlt(localctx, 1)
                self.state = 274
                self.forLoop()
                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 2)
                self.state = 275
                self.whileLoop()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForLoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(EnglishLangParser.FOR, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.SEMICOLON)
            else:
                return self.getToken(EnglishLangParser.SEMICOLON, i)

        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def variableDeclaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.VariableDeclarationContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationContext,i)


        def reassignment(self):
            return self.getTypedRuleContext(EnglishLangParser.ReassignmentContext,0)


        def operation(self):
            return self.getTypedRuleContext(EnglishLangParser.OperationContext,0)


        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def statement(self):
            return self.getTypedRuleContext(EnglishLangParser.StatementContext,0)


        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.LoopStatementsContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_forLoop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForLoop" ):
                listener.enterForLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForLoop" ):
                listener.exitForLoop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForLoop" ):
                return visitor.visitForLoop(self)
            else:
                return visitor.visitChildren(self)




    def forLoop(self):

        localctx = EnglishLangParser.ForLoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_forLoop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 278
            self.match(EnglishLangParser.FOR)
            self.state = 279
            self.match(EnglishLangParser.LPAREN)
            self.state = 282
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [70]:
                self.state = 280
                self.match(EnglishLangParser.IDENTIFIER)
                pass
            elif token in [8]:
                self.state = 281
                self.variableDeclaration()
                pass
            elif token in [44]:
                pass
            else:
                pass
            self.state = 284
            self.match(EnglishLangParser.SEMICOLON)
            self.state = 285
            self.boolExpression(0)
            self.state = 286
            self.match(EnglishLangParser.SEMICOLON)
            self.state = 290
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.state = 287
                self.variableDeclaration()
                pass

            elif la_ == 2:
                self.state = 288
                self.reassignment()
                pass

            elif la_ == 3:
                self.state = 289
                self.operation()
                pass


            self.state = 292
            self.match(EnglishLangParser.RPAREN)
            self.state = 302
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51]:
                self.state = 293
                self.match(EnglishLangParser.LBRACE)
                self.state = 295 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 294
                    self.loopStatements()
                    self.state = 297 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815293224) != 0) or _la==70):
                        break

                self.state = 299
                self.match(EnglishLangParser.RBRACE)
                pass
            elif token in [3, 5, 8, 10, 11, 15, 20, 65, 66, 67, 68, 69, 70]:
                self.state = 301
                self.statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileLoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(EnglishLangParser.WHILE, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def statement(self):
            return self.getTypedRuleContext(EnglishLangParser.StatementContext,0)


        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.LoopStatementsContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_whileLoop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileLoop" ):
                listener.enterWhileLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileLoop" ):
                listener.exitWhileLoop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileLoop" ):
                return visitor.visitWhileLoop(self)
            else:
                return visitor.visitChildren(self)




    def whileLoop(self):

        localctx = EnglishLangParser.WhileLoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_whileLoop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            self.match(EnglishLangParser.WHILE)
            self.state = 305
            self.match(EnglishLangParser.LPAREN)
            self.state = 306
            self.boolExpression(0)
            self.state = 307
            self.match(EnglishLangParser.RPAREN)
            self.state = 317
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51]:
                self.state = 308
                self.match(EnglishLangParser.LBRACE)
                self.state = 310 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 309
                    self.loopStatements()
                    self.state = 312 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815293224) != 0) or _la==70):
                        break

                self.state = 314
                self.match(EnglishLangParser.RBRACE)
                pass
            elif token in [3, 5, 8, 10, 11, 15, 20, 65, 66, 67, 68, 69, 70]:
                self.state = 316
                self.statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DisplayStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISPLAY(self):
            return self.getToken(EnglishLangParser.DISPLAY, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_displayStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDisplayStatement" ):
                listener.enterDisplayStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDisplayStatement" ):
                listener.exitDisplayStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisplayStatement" ):
                return visitor.visitDisplayStatement(self)
            else:
                return visitor.visitChildren(self)




    def displayStatement(self):

        localctx = EnglishLangParser.DisplayStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_displayStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 319
            self.match(EnglishLangParser.DISPLAY)
            self.state = 320
            self.expression()
            self.state = 325
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==45:
                self.state = 321
                self.match(EnglishLangParser.COMMA)
                self.state = 322
                self.expression()
                self.state = 327
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typedParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.TypedParameterContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.TypedParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = EnglishLangParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_parameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 328
            self.typedParameter()
            self.state = 333
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==45:
                self.state = 329
                self.match(EnglishLangParser.COMMA)
                self.state = 330
                self.typedParameter()
                self.state = 335
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypedParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def typeAnnotation(self):
            return self.getTypedRuleContext(EnglishLangParser.TypeAnnotationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_typedParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypedParameter" ):
                listener.enterTypedParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypedParameter" ):
                listener.exitTypedParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypedParameter" ):
                return visitor.visitTypedParameter(self)
            else:
                return visitor.visitChildren(self)




    def typedParameter(self):

        localctx = EnglishLangParser.TypedParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_typedParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 337
            self.typeAnnotation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock" ):
                listener.enterBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock" ):
                listener.exitBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock" ):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)




    def block(self):

        localctx = EnglishLangParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 339
            self.match(EnglishLangParser.LBRACE)
            self.state = 341 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 340
                self.statement()
                self.state = 343 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1084712) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 63) != 0)):
                    break

            self.state = 345
            self.match(EnglishLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self):
            return self.getTypedRuleContext(EnglishLangParser.TermContext,0)


        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def PLUS(self):
            return self.getToken(EnglishLangParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(EnglishLangParser.MINUS, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_numExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumExpression" ):
                listener.enterNumExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumExpression" ):
                listener.exitNumExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumExpression" ):
                return visitor.visitNumExpression(self)
            else:
                return visitor.visitChildren(self)



    def numExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = EnglishLangParser.NumExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 50
        self.enterRecursionRule(localctx, 50, self.RULE_numExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 348
            self.term(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 355
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,39,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = EnglishLangParser.NumExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_numExpression)
                    self.state = 350
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 351
                    _la = self._input.LA(1)
                    if not(_la==24 or _la==25):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 352
                    self.term(0) 
                self.state = 357
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,39,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self):
            return self.getTypedRuleContext(EnglishLangParser.FactorContext,0)


        def term(self):
            return self.getTypedRuleContext(EnglishLangParser.TermContext,0)


        def MULTIPLY(self):
            return self.getToken(EnglishLangParser.MULTIPLY, 0)

        def DIVIDED_BY(self):
            return self.getToken(EnglishLangParser.DIVIDED_BY, 0)

        def MODULO(self):
            return self.getToken(EnglishLangParser.MODULO, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm" ):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)



    def term(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = EnglishLangParser.TermContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 52
        self.enterRecursionRule(localctx, 52, self.RULE_term, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 359
            self.factor()
            self._ctx.stop = self._input.LT(-1)
            self.state = 366
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,40,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = EnglishLangParser.TermContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_term)
                    self.state = 361
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 362
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 469762048) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 363
                    self.factor() 
                self.state = 368
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,40,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class FactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(EnglishLangParser.NUMBER, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def operation(self):
            return self.getTypedRuleContext(EnglishLangParser.OperationContext,0)


        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_factor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactor" ):
                listener.enterFactor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactor" ):
                listener.exitFactor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactor" ):
                return visitor.visitFactor(self)
            else:
                return visitor.visitChildren(self)




    def factor(self):

        localctx = EnglishLangParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_factor)
        try:
            self.state = 376
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 369
                self.match(EnglishLangParser.NUMBER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 370
                self.match(EnglishLangParser.IDENTIFIER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 371
                self.operation()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 372
                self.match(EnglishLangParser.LPAREN)
                self.state = 373
                self.numExpression(0)
                self.state = 374
                self.match(EnglishLangParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def INCREMENT(self):
            return self.getToken(EnglishLangParser.INCREMENT, 0)

        def DECREMENT(self):
            return self.getToken(EnglishLangParser.DECREMENT, 0)

        def functionCall(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionCallContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_operation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperation" ):
                listener.enterOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperation" ):
                listener.exitOperation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperation" ):
                return visitor.visitOperation(self)
            else:
                return visitor.visitChildren(self)




    def operation(self):

        localctx = EnglishLangParser.OperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_operation)
        self._la = 0 # Token type
        try:
            self.state = 381
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 378
                self.match(EnglishLangParser.IDENTIFIER)
                self.state = 379
                _la = self._input.LA(1)
                if not(_la==36 or _la==37):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 380
                self.functionCall()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReassignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def SEMICOLON(self):
            return self.getToken(EnglishLangParser.SEMICOLON, 0)

        def SUBTRACT_FROM(self):
            return self.getToken(EnglishLangParser.SUBTRACT_FROM, 0)

        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def DIVIDE_FROM(self):
            return self.getToken(EnglishLangParser.DIVIDE_FROM, 0)

        def TIMES(self):
            return self.getToken(EnglishLangParser.TIMES, 0)

        def ADD_TO(self):
            return self.getToken(EnglishLangParser.ADD_TO, 0)

        def STRING(self):
            return self.getToken(EnglishLangParser.STRING, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_reassignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReassignment" ):
                listener.enterReassignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReassignment" ):
                listener.exitReassignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReassignment" ):
                return visitor.visitReassignment(self)
            else:
                return visitor.visitChildren(self)




    def reassignment(self):

        localctx = EnglishLangParser.ReassignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_reassignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 396
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [34]:
                self.state = 388
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
                if la_ == 1:
                    self.state = 384
                    self.match(EnglishLangParser.ADD_TO)
                    self.state = 385
                    self.match(EnglishLangParser.STRING)
                    pass

                elif la_ == 2:
                    self.state = 386
                    self.match(EnglishLangParser.ADD_TO)
                    self.state = 387
                    self.numExpression(0)
                    pass


                pass
            elif token in [35]:
                self.state = 390
                self.match(EnglishLangParser.SUBTRACT_FROM)
                self.state = 391
                self.numExpression(0)
                pass
            elif token in [39]:
                self.state = 392
                self.match(EnglishLangParser.DIVIDE_FROM)
                self.state = 393
                self.numExpression(0)
                pass
            elif token in [38]:
                self.state = 394
                self.match(EnglishLangParser.TIMES)
                self.state = 395
                self.numExpression(0)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 398
            self.match(EnglishLangParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None # Token

        def numExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.NumExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,i)


        def comparisonOp(self):
            return self.getTypedRuleContext(EnglishLangParser.ComparisonOpContext,0)


        def stringExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StringExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StringExpressionContext,i)


        def EQUALS(self):
            return self.getToken(EnglishLangParser.EQUALS, 0)

        def NOT_EQUALS(self):
            return self.getToken(EnglishLangParser.NOT_EQUALS, 0)

        def matrixExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.MatrixExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.MatrixExpressionContext,i)


        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def boolExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,i)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def NOT(self):
            return self.getToken(EnglishLangParser.NOT, 0)

        def TRUE_VALUE(self):
            return self.getToken(EnglishLangParser.TRUE_VALUE, 0)

        def FALSE_VALUE(self):
            return self.getToken(EnglishLangParser.FALSE_VALUE, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def AND(self):
            return self.getToken(EnglishLangParser.AND, 0)

        def OR(self):
            return self.getToken(EnglishLangParser.OR, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_boolExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolExpression" ):
                listener.enterBoolExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolExpression" ):
                listener.exitBoolExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolExpression" ):
                return visitor.visitBoolExpression(self)
            else:
                return visitor.visitChildren(self)



    def boolExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = EnglishLangParser.BoolExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 60
        self.enterRecursionRule(localctx, 60, self.RULE_boolExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 426
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.state = 401
                self.numExpression(0)
                self.state = 402
                self.comparisonOp()
                self.state = 403
                self.numExpression(0)
                pass

            elif la_ == 2:
                self.state = 405
                self.stringExpression()
                self.state = 406
                localctx.operator = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==29 or _la==40):
                    localctx.operator = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 407
                self.stringExpression()
                pass

            elif la_ == 3:
                self.state = 409
                self.matrixExpression()
                self.state = 410
                localctx.operator = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==29 or _la==40):
                    localctx.operator = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 411
                self.matrixExpression()
                pass

            elif la_ == 4:
                self.state = 414
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==43:
                    self.state = 413
                    self.match(EnglishLangParser.NOT)


                self.state = 416
                self.match(EnglishLangParser.LPAREN)
                self.state = 417
                self.boolExpression(0)
                self.state = 418
                self.match(EnglishLangParser.RPAREN)
                pass

            elif la_ == 5:
                self.state = 420
                self.match(EnglishLangParser.TRUE_VALUE)
                pass

            elif la_ == 6:
                self.state = 421
                self.match(EnglishLangParser.FALSE_VALUE)
                pass

            elif la_ == 7:
                self.state = 423
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==43:
                    self.state = 422
                    self.match(EnglishLangParser.NOT)


                self.state = 425
                self.match(EnglishLangParser.IDENTIFIER)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 433
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,48,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = EnglishLangParser.BoolExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_boolExpression)
                    self.state = 428
                    if not self.precpred(self._ctx, 5):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                    self.state = 429
                    localctx.operator = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==41 or _la==42):
                        localctx.operator = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 430
                    self.boolExpression(6) 
                self.state = 435
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,48,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ComparisonOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUALS(self):
            return self.getToken(EnglishLangParser.EQUALS, 0)

        def GREATER_THAN(self):
            return self.getToken(EnglishLangParser.GREATER_THAN, 0)

        def LESS_THAN(self):
            return self.getToken(EnglishLangParser.LESS_THAN, 0)

        def GREATER_EQUAL(self):
            return self.getToken(EnglishLangParser.GREATER_EQUAL, 0)

        def LESS_EQUAL(self):
            return self.getToken(EnglishLangParser.LESS_EQUAL, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_comparisonOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOp" ):
                listener.enterComparisonOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOp" ):
                listener.exitComparisonOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOp" ):
                return visitor.visitComparisonOp(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOp(self):

        localctx = EnglishLangParser.ComparisonOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_comparisonOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 436
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 16642998272) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[25] = self.numExpression_sempred
        self._predicates[26] = self.term_sempred
        self._predicates[30] = self.boolExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def numExpression_sempred(self, localctx:NumExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def term_sempred(self, localctx:TermContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 2)
         

    def boolExpression_sempred(self, localctx:BoolExpressionContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 5)
         




