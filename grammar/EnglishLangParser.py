# Generated from EnglishLangParser.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,73,508,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,1,0,1,0,4,0,85,8,0,11,0,12,0,86,1,0,1,0,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,103,8,1,1,2,1,2,1,2,1,2,1,
        2,1,2,1,2,1,2,1,2,3,2,114,8,2,1,3,1,3,1,3,1,3,1,3,3,3,121,8,3,1,
        3,1,3,1,3,3,3,126,8,3,1,4,3,4,129,8,4,1,4,1,4,3,4,133,8,4,1,5,1,
        5,3,5,137,8,5,1,6,1,6,1,6,1,6,5,6,143,8,6,10,6,12,6,146,9,6,1,6,
        1,6,1,7,1,7,1,7,5,7,153,8,7,10,7,12,7,156,9,7,1,8,1,8,1,9,1,9,1,
        9,5,9,163,8,9,10,9,12,9,166,9,9,1,10,1,10,1,10,1,10,1,10,1,10,1,
        10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,3,10,182,8,10,1,11,1,11,4,
        11,186,8,11,11,11,12,11,187,1,11,1,11,1,12,1,12,1,13,1,13,1,13,1,
        13,3,13,198,8,13,1,13,1,13,1,13,1,13,1,14,1,14,1,14,5,14,207,8,14,
        10,14,12,14,210,9,14,1,15,1,15,3,15,214,8,15,1,16,1,16,1,16,1,17,
        3,17,220,8,17,1,17,1,17,1,17,3,17,225,8,17,1,17,1,17,1,18,1,18,1,
        18,5,18,232,8,18,10,18,12,18,235,9,18,1,19,1,19,1,19,1,19,1,19,1,
        19,1,19,1,19,1,19,1,19,1,19,1,19,3,19,249,8,19,1,20,1,20,1,20,1,
        20,1,20,1,20,3,20,257,8,20,1,20,1,20,1,20,1,20,1,20,1,20,3,20,265,
        8,20,5,20,267,8,20,10,20,12,20,270,9,20,1,20,1,20,1,20,3,20,275,
        8,20,3,20,277,8,20,1,21,1,21,1,21,1,21,1,21,1,21,4,21,285,8,21,11,
        21,12,21,286,1,21,1,21,1,21,3,21,292,8,21,1,21,1,21,1,21,1,21,1,
        21,1,21,4,21,300,8,21,11,21,12,21,301,1,21,1,21,1,21,3,21,307,8,
        21,5,21,309,8,21,10,21,12,21,312,9,21,1,21,1,21,1,21,4,21,317,8,
        21,11,21,12,21,318,1,21,1,21,1,21,3,21,324,8,21,3,21,326,8,21,1,
        22,1,22,3,22,330,8,22,1,23,1,23,1,23,3,23,335,8,23,1,23,1,23,1,23,
        1,23,1,23,1,23,1,23,1,24,1,24,3,24,346,8,24,1,25,1,25,1,25,3,25,
        351,8,25,1,26,1,26,4,26,355,8,26,11,26,12,26,356,1,26,1,26,1,26,
        3,26,362,8,26,1,27,1,27,1,27,1,27,1,27,1,27,4,27,370,8,27,11,27,
        12,27,371,1,27,1,27,1,27,3,27,377,8,27,1,28,1,28,1,28,1,28,5,28,
        383,8,28,10,28,12,28,386,9,28,1,29,1,29,5,29,390,8,29,10,29,12,29,
        393,9,29,1,29,1,29,1,30,1,30,1,30,1,30,1,30,1,30,5,30,403,8,30,10,
        30,12,30,406,9,30,1,31,1,31,1,31,1,31,1,31,1,31,5,31,414,8,31,10,
        31,12,31,417,9,31,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,
        32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,438,8,32,1,
        33,1,33,1,33,3,33,443,8,33,1,34,1,34,1,34,1,34,1,34,3,34,450,8,34,
        1,34,1,34,1,34,1,34,1,34,1,34,3,34,458,8,34,1,34,1,34,1,35,1,35,
        1,36,1,36,1,36,5,36,467,8,36,10,36,12,36,470,9,36,1,37,1,37,1,37,
        5,37,475,8,37,10,37,12,37,478,9,37,1,38,1,38,1,38,3,38,483,8,38,
        1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,
        1,39,1,39,1,39,1,39,1,39,1,39,3,39,504,8,39,1,40,1,40,1,40,0,2,60,
        62,41,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,
        42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,0,9,
        2,0,56,56,71,71,2,0,57,57,71,71,1,0,58,62,1,0,67,70,1,0,25,26,1,
        0,27,29,1,0,37,38,2,0,30,30,41,41,2,0,30,34,41,41,561,0,82,1,0,0,
        0,2,102,1,0,0,0,4,113,1,0,0,0,6,125,1,0,0,0,8,128,1,0,0,0,10,136,
        1,0,0,0,12,138,1,0,0,0,14,149,1,0,0,0,16,157,1,0,0,0,18,159,1,0,
        0,0,20,181,1,0,0,0,22,185,1,0,0,0,24,191,1,0,0,0,26,193,1,0,0,0,
        28,203,1,0,0,0,30,211,1,0,0,0,32,215,1,0,0,0,34,219,1,0,0,0,36,228,
        1,0,0,0,38,248,1,0,0,0,40,250,1,0,0,0,42,278,1,0,0,0,44,329,1,0,
        0,0,46,331,1,0,0,0,48,345,1,0,0,0,50,350,1,0,0,0,52,361,1,0,0,0,
        54,363,1,0,0,0,56,378,1,0,0,0,58,387,1,0,0,0,60,396,1,0,0,0,62,407,
        1,0,0,0,64,437,1,0,0,0,66,439,1,0,0,0,68,444,1,0,0,0,70,461,1,0,
        0,0,72,463,1,0,0,0,74,471,1,0,0,0,76,482,1,0,0,0,78,503,1,0,0,0,
        80,505,1,0,0,0,82,84,5,1,0,0,83,85,3,2,1,0,84,83,1,0,0,0,85,86,1,
        0,0,0,86,84,1,0,0,0,86,87,1,0,0,0,87,88,1,0,0,0,88,89,5,2,0,0,89,
        1,1,0,0,0,90,103,3,6,3,0,91,103,3,68,34,0,92,103,3,26,13,0,93,103,
        3,34,17,0,94,103,3,32,16,0,95,103,3,56,28,0,96,103,3,40,20,0,97,
        103,3,44,22,0,98,103,3,46,23,0,99,103,3,54,27,0,100,103,3,58,29,
        0,101,103,3,66,33,0,102,90,1,0,0,0,102,91,1,0,0,0,102,92,1,0,0,0,
        102,93,1,0,0,0,102,94,1,0,0,0,102,95,1,0,0,0,102,96,1,0,0,0,102,
        97,1,0,0,0,102,98,1,0,0,0,102,99,1,0,0,0,102,100,1,0,0,0,102,101,
        1,0,0,0,103,3,1,0,0,0,104,114,3,44,22,0,105,114,3,6,3,0,106,114,
        3,68,34,0,107,114,3,26,13,0,108,114,3,32,16,0,109,114,3,42,21,0,
        110,114,3,58,29,0,111,114,5,18,0,0,112,114,3,56,28,0,113,104,1,0,
        0,0,113,105,1,0,0,0,113,106,1,0,0,0,113,107,1,0,0,0,113,108,1,0,
        0,0,113,109,1,0,0,0,113,110,1,0,0,0,113,111,1,0,0,0,113,112,1,0,
        0,0,114,5,1,0,0,0,115,116,5,7,0,0,116,117,5,71,0,0,117,118,5,8,0,
        0,118,120,3,20,10,0,119,121,3,24,12,0,120,119,1,0,0,0,120,121,1,
        0,0,0,121,126,1,0,0,0,122,123,5,71,0,0,123,124,5,8,0,0,124,126,3,
        20,10,0,125,115,1,0,0,0,125,122,1,0,0,0,126,7,1,0,0,0,127,129,5,
        21,0,0,128,127,1,0,0,0,128,129,1,0,0,0,129,130,1,0,0,0,130,132,3,
        10,5,0,131,133,5,22,0,0,132,131,1,0,0,0,132,133,1,0,0,0,133,9,1,
        0,0,0,134,137,5,71,0,0,135,137,3,12,6,0,136,134,1,0,0,0,136,135,
        1,0,0,0,137,11,1,0,0,0,138,139,5,50,0,0,139,144,3,14,7,0,140,141,
        5,45,0,0,141,143,3,14,7,0,142,140,1,0,0,0,143,146,1,0,0,0,144,142,
        1,0,0,0,144,145,1,0,0,0,145,147,1,0,0,0,146,144,1,0,0,0,147,148,
        5,51,0,0,148,13,1,0,0,0,149,154,3,16,8,0,150,151,5,46,0,0,151,153,
        3,16,8,0,152,150,1,0,0,0,153,156,1,0,0,0,154,152,1,0,0,0,154,155,
        1,0,0,0,155,15,1,0,0,0,156,154,1,0,0,0,157,158,7,0,0,0,158,17,1,
        0,0,0,159,164,7,1,0,0,160,161,5,25,0,0,161,163,7,1,0,0,162,160,1,
        0,0,0,163,166,1,0,0,0,164,162,1,0,0,0,164,165,1,0,0,0,165,19,1,0,
        0,0,166,164,1,0,0,0,167,182,3,34,17,0,168,182,3,38,19,0,169,182,
        3,60,30,0,170,182,3,70,35,0,171,182,3,8,4,0,172,182,3,18,9,0,173,
        182,5,56,0,0,174,182,5,57,0,0,175,182,3,22,11,0,176,182,5,71,0,0,
        177,178,5,54,0,0,178,179,3,20,10,0,179,180,5,55,0,0,180,182,1,0,
        0,0,181,167,1,0,0,0,181,168,1,0,0,0,181,169,1,0,0,0,181,170,1,0,
        0,0,181,171,1,0,0,0,181,172,1,0,0,0,181,173,1,0,0,0,181,174,1,0,
        0,0,181,175,1,0,0,0,181,176,1,0,0,0,181,177,1,0,0,0,182,21,1,0,0,
        0,183,184,5,23,0,0,184,186,5,24,0,0,185,183,1,0,0,0,186,187,1,0,
        0,0,187,185,1,0,0,0,187,188,1,0,0,0,188,189,1,0,0,0,189,190,5,71,
        0,0,190,23,1,0,0,0,191,192,7,2,0,0,192,25,1,0,0,0,193,194,5,3,0,
        0,194,195,5,71,0,0,195,197,5,54,0,0,196,198,3,28,14,0,197,196,1,
        0,0,0,197,198,1,0,0,0,198,199,1,0,0,0,199,200,5,55,0,0,200,201,3,
        58,29,0,201,202,5,4,0,0,202,27,1,0,0,0,203,208,3,30,15,0,204,205,
        5,46,0,0,205,207,3,30,15,0,206,204,1,0,0,0,207,210,1,0,0,0,208,206,
        1,0,0,0,208,209,1,0,0,0,209,29,1,0,0,0,210,208,1,0,0,0,211,213,5,
        71,0,0,212,214,3,24,12,0,213,212,1,0,0,0,213,214,1,0,0,0,214,31,
        1,0,0,0,215,216,5,5,0,0,216,217,3,20,10,0,217,33,1,0,0,0,218,220,
        5,6,0,0,219,218,1,0,0,0,219,220,1,0,0,0,220,221,1,0,0,0,221,222,
        5,71,0,0,222,224,5,54,0,0,223,225,3,36,18,0,224,223,1,0,0,0,224,
        225,1,0,0,0,225,226,1,0,0,0,226,227,5,55,0,0,227,35,1,0,0,0,228,
        233,3,20,10,0,229,230,5,46,0,0,230,232,3,20,10,0,231,229,1,0,0,0,
        232,235,1,0,0,0,233,231,1,0,0,0,233,234,1,0,0,0,234,37,1,0,0,0,235,
        233,1,0,0,0,236,237,5,66,0,0,237,238,5,54,0,0,238,239,3,60,30,0,
        239,240,5,46,0,0,240,241,3,60,30,0,241,242,5,55,0,0,242,249,1,0,
        0,0,243,244,7,3,0,0,244,245,5,54,0,0,245,246,3,60,30,0,246,247,5,
        55,0,0,247,249,1,0,0,0,248,236,1,0,0,0,248,243,1,0,0,0,249,39,1,
        0,0,0,250,251,5,10,0,0,251,252,5,54,0,0,252,253,3,70,35,0,253,256,
        5,55,0,0,254,257,3,2,1,0,255,257,3,58,29,0,256,254,1,0,0,0,256,255,
        1,0,0,0,257,268,1,0,0,0,258,259,5,11,0,0,259,260,5,54,0,0,260,261,
        3,70,35,0,261,264,5,55,0,0,262,265,3,2,1,0,263,265,3,58,29,0,264,
        262,1,0,0,0,264,263,1,0,0,0,265,267,1,0,0,0,266,258,1,0,0,0,267,
        270,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,276,1,0,0,0,270,
        268,1,0,0,0,271,274,5,12,0,0,272,275,3,2,1,0,273,275,3,58,29,0,274,
        272,1,0,0,0,274,273,1,0,0,0,275,277,1,0,0,0,276,271,1,0,0,0,276,
        277,1,0,0,0,277,41,1,0,0,0,278,279,5,10,0,0,279,280,5,54,0,0,280,
        281,3,70,35,0,281,291,5,55,0,0,282,284,5,52,0,0,283,285,3,4,2,0,
        284,283,1,0,0,0,285,286,1,0,0,0,286,284,1,0,0,0,286,287,1,0,0,0,
        287,288,1,0,0,0,288,289,5,53,0,0,289,292,1,0,0,0,290,292,3,2,1,0,
        291,282,1,0,0,0,291,290,1,0,0,0,292,310,1,0,0,0,293,294,5,11,0,0,
        294,295,5,54,0,0,295,296,3,70,35,0,296,306,5,55,0,0,297,299,5,52,
        0,0,298,300,3,4,2,0,299,298,1,0,0,0,300,301,1,0,0,0,301,299,1,0,
        0,0,301,302,1,0,0,0,302,303,1,0,0,0,303,304,5,53,0,0,304,307,1,0,
        0,0,305,307,3,2,1,0,306,297,1,0,0,0,306,305,1,0,0,0,307,309,1,0,
        0,0,308,293,1,0,0,0,309,312,1,0,0,0,310,308,1,0,0,0,310,311,1,0,
        0,0,311,325,1,0,0,0,312,310,1,0,0,0,313,323,5,12,0,0,314,316,5,52,
        0,0,315,317,3,4,2,0,316,315,1,0,0,0,317,318,1,0,0,0,318,316,1,0,
        0,0,318,319,1,0,0,0,319,320,1,0,0,0,320,321,5,53,0,0,321,324,1,0,
        0,0,322,324,3,2,1,0,323,314,1,0,0,0,323,322,1,0,0,0,324,326,1,0,
        0,0,325,313,1,0,0,0,325,326,1,0,0,0,326,43,1,0,0,0,327,330,3,46,
        23,0,328,330,3,54,27,0,329,327,1,0,0,0,329,328,1,0,0,0,330,45,1,
        0,0,0,331,332,5,14,0,0,332,334,5,54,0,0,333,335,3,48,24,0,334,333,
        1,0,0,0,334,335,1,0,0,0,335,336,1,0,0,0,336,337,5,45,0,0,337,338,
        3,70,35,0,338,339,5,45,0,0,339,340,3,50,25,0,340,341,5,55,0,0,341,
        342,3,52,26,0,342,47,1,0,0,0,343,346,5,71,0,0,344,346,3,6,3,0,345,
        343,1,0,0,0,345,344,1,0,0,0,346,49,1,0,0,0,347,351,3,6,3,0,348,351,
        3,68,34,0,349,351,3,66,33,0,350,347,1,0,0,0,350,348,1,0,0,0,350,
        349,1,0,0,0,351,51,1,0,0,0,352,354,5,52,0,0,353,355,3,4,2,0,354,
        353,1,0,0,0,355,356,1,0,0,0,356,354,1,0,0,0,356,357,1,0,0,0,357,
        358,1,0,0,0,358,359,5,53,0,0,359,362,1,0,0,0,360,362,3,2,1,0,361,
        352,1,0,0,0,361,360,1,0,0,0,362,53,1,0,0,0,363,364,5,19,0,0,364,
        365,5,54,0,0,365,366,3,70,35,0,366,376,5,55,0,0,367,369,5,52,0,0,
        368,370,3,4,2,0,369,368,1,0,0,0,370,371,1,0,0,0,371,369,1,0,0,0,
        371,372,1,0,0,0,372,373,1,0,0,0,373,374,5,53,0,0,374,377,1,0,0,0,
        375,377,3,2,1,0,376,367,1,0,0,0,376,375,1,0,0,0,377,55,1,0,0,0,378,
        379,5,9,0,0,379,384,3,20,10,0,380,381,5,46,0,0,381,383,3,20,10,0,
        382,380,1,0,0,0,383,386,1,0,0,0,384,382,1,0,0,0,384,385,1,0,0,0,
        385,57,1,0,0,0,386,384,1,0,0,0,387,391,5,52,0,0,388,390,3,2,1,0,
        389,388,1,0,0,0,390,393,1,0,0,0,391,389,1,0,0,0,391,392,1,0,0,0,
        392,394,1,0,0,0,393,391,1,0,0,0,394,395,5,53,0,0,395,59,1,0,0,0,
        396,397,6,30,-1,0,397,398,3,62,31,0,398,404,1,0,0,0,399,400,10,2,
        0,0,400,401,7,4,0,0,401,403,3,62,31,0,402,399,1,0,0,0,403,406,1,
        0,0,0,404,402,1,0,0,0,404,405,1,0,0,0,405,61,1,0,0,0,406,404,1,0,
        0,0,407,408,6,31,-1,0,408,409,3,64,32,0,409,415,1,0,0,0,410,411,
        10,2,0,0,411,412,7,5,0,0,412,414,3,64,32,0,413,410,1,0,0,0,414,417,
        1,0,0,0,415,413,1,0,0,0,415,416,1,0,0,0,416,63,1,0,0,0,417,415,1,
        0,0,0,418,419,5,25,0,0,419,438,3,64,32,0,420,421,5,26,0,0,421,438,
        3,64,32,0,422,438,3,34,17,0,423,438,5,56,0,0,424,438,3,22,11,0,425,
        438,5,71,0,0,426,438,5,57,0,0,427,438,3,66,33,0,428,429,5,54,0,0,
        429,430,3,60,30,0,430,431,5,55,0,0,431,438,1,0,0,0,432,433,5,54,
        0,0,433,434,3,24,12,0,434,435,5,55,0,0,435,436,3,64,32,0,436,438,
        1,0,0,0,437,418,1,0,0,0,437,420,1,0,0,0,437,422,1,0,0,0,437,423,
        1,0,0,0,437,424,1,0,0,0,437,425,1,0,0,0,437,426,1,0,0,0,437,427,
        1,0,0,0,437,428,1,0,0,0,437,432,1,0,0,0,438,65,1,0,0,0,439,440,5,
        71,0,0,440,442,7,6,0,0,441,443,5,45,0,0,442,441,1,0,0,0,442,443,
        1,0,0,0,443,67,1,0,0,0,444,457,5,71,0,0,445,446,5,35,0,0,446,450,
        5,57,0,0,447,448,5,35,0,0,448,450,3,60,30,0,449,445,1,0,0,0,449,
        447,1,0,0,0,450,458,1,0,0,0,451,452,5,36,0,0,452,458,3,60,30,0,453,
        454,5,40,0,0,454,458,3,60,30,0,455,456,5,39,0,0,456,458,3,60,30,
        0,457,449,1,0,0,0,457,451,1,0,0,0,457,453,1,0,0,0,457,455,1,0,0,
        0,458,459,1,0,0,0,459,460,5,45,0,0,460,69,1,0,0,0,461,462,3,72,36,
        0,462,71,1,0,0,0,463,468,3,74,37,0,464,465,5,43,0,0,465,467,3,74,
        37,0,466,464,1,0,0,0,467,470,1,0,0,0,468,466,1,0,0,0,468,469,1,0,
        0,0,469,73,1,0,0,0,470,468,1,0,0,0,471,476,3,76,38,0,472,473,5,42,
        0,0,473,475,3,76,38,0,474,472,1,0,0,0,475,478,1,0,0,0,476,474,1,
        0,0,0,476,477,1,0,0,0,477,75,1,0,0,0,478,476,1,0,0,0,479,480,5,44,
        0,0,480,483,3,76,38,0,481,483,3,78,39,0,482,479,1,0,0,0,482,481,
        1,0,0,0,483,77,1,0,0,0,484,485,3,60,30,0,485,486,3,80,40,0,486,487,
        3,60,30,0,487,504,1,0,0,0,488,489,3,18,9,0,489,490,7,7,0,0,490,491,
        3,18,9,0,491,504,1,0,0,0,492,493,3,8,4,0,493,494,7,7,0,0,494,495,
        3,8,4,0,495,504,1,0,0,0,496,497,5,54,0,0,497,498,3,70,35,0,498,499,
        5,55,0,0,499,504,1,0,0,0,500,504,5,64,0,0,501,504,5,65,0,0,502,504,
        5,71,0,0,503,484,1,0,0,0,503,488,1,0,0,0,503,492,1,0,0,0,503,496,
        1,0,0,0,503,500,1,0,0,0,503,501,1,0,0,0,503,502,1,0,0,0,504,79,1,
        0,0,0,505,506,7,8,0,0,506,81,1,0,0,0,53,86,102,113,120,125,128,132,
        136,144,154,164,181,187,197,208,213,219,224,233,248,256,264,268,
        274,276,286,291,301,306,310,318,323,325,329,334,345,350,356,361,
        371,376,384,391,404,415,437,442,449,457,468,476,482,503
    ]

class EnglishLangParser ( Parser ):

    grammarFileName = "EnglishLangParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'Start Program'", "'End Program'", "'Define Function'", 
                     "'End Function'", "'Return'", "'Call'", "'Set'", "'to'", 
                     "'Display'", "'If'", "'Else If'", "'Else'", "'End If'", 
                     "'For'", "'from'", "'in'", "'End For'", "'break'", 
                     "'While'", "'End While'", "'invert'", "''T'", "'parent'", 
                     "'::'", "'+'", "'-'", "'*'", "'/'", "'%'", "'=='", 
                     "'>'", "'<'", "'>='", "'<='", "'+='", "'-='", "'++'", 
                     "'--'", "'*='", "'/='", "'!='", "'and'", "'or'", "'not'", 
                     "';'", "','", "':'", "'.'", "'\"'", "'['", "']'", "'{'", 
                     "'}'", "'('", "')'", "<INVALID>", "<INVALID>", "'int'", 
                     "'string'", "'bool'", "'float'", "'matrix'", "'void'", 
                     "'true'", "'false'", "'pow'", "'sin'", "'cos'", "'tan'", 
                     "'ctan'" ]

    symbolicNames = [ "<INVALID>", "START_PROGRAM", "END_PROGRAM", "DEFINE_FUNCTION", 
                      "END_FUNCTION", "RETURN", "CALL", "SET", "TO", "DISPLAY", 
                      "IF", "ELSE_IF", "ELSE", "END_IF", "FOR", "FROM", 
                      "IN", "END_FOR", "BREAK", "WHILE", "END_WHILE", "INVERT_MATRIX", 
                      "TRANSPOSITION", "PARENT_SCOPE", "DCOLON", "PLUS", 
                      "MINUS", "MULTIPLY", "DIVIDED_BY", "MODULO", "EQUALS", 
                      "GREATER_THAN", "LESS_THAN", "GREATER_EQUAL", "LESS_EQUAL", 
                      "ADD_TO", "SUBTRACT_FROM", "INCREMENT", "DECREMENT", 
                      "TIMES", "DIVIDE_FROM", "NOT_EQUALS", "AND", "OR", 
                      "NOT", "SEMICOLON", "COMMA", "COLON", "DOT", "QUOTE", 
                      "LBRACK", "RBRACK", "LBRACE", "RBRACE", "LPAREN", 
                      "RPAREN", "NUMBER", "STRING", "TYPE_INT", "TYPE_STRING", 
                      "TYPE_BOOL", "TYPE_FLOAT", "TYPE_MATRIX", "TYPE_VOID", 
                      "TRUE_VALUE", "FALSE_VALUE", "POWER_FUNC", "SIN_FUNC", 
                      "COS_FUNC", "TAN_FUNC", "CTAN_FUNC", "IDENTIFIER", 
                      "WS", "COMMENT" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_loopStatements = 2
    RULE_variableDeclarationOrAssignment = 3
    RULE_matrixExpression = 4
    RULE_matrixAtom = 5
    RULE_matrixConstruction = 6
    RULE_row = 7
    RULE_value = 8
    RULE_stringExpression = 9
    RULE_expression = 10
    RULE_scopedIdentifier = 11
    RULE_typeAnnotation = 12
    RULE_functionDeclaration = 13
    RULE_parameter = 14
    RULE_typedParameter = 15
    RULE_returnStatement = 16
    RULE_functionCall = 17
    RULE_argumentList = 18
    RULE_builtInFunctions = 19
    RULE_ifStatement = 20
    RULE_loopIfStatement = 21
    RULE_loopStatement = 22
    RULE_forLoop = 23
    RULE_forInit = 24
    RULE_forUpdate = 25
    RULE_forBody = 26
    RULE_whileLoop = 27
    RULE_displayStatement = 28
    RULE_blockStatement = 29
    RULE_numExpression = 30
    RULE_term = 31
    RULE_factor = 32
    RULE_operation = 33
    RULE_reassignment = 34
    RULE_boolExpression = 35
    RULE_boolOrExpression = 36
    RULE_boolAndExpression = 37
    RULE_boolNotExpression = 38
    RULE_boolPrimary = 39
    RULE_comparisonOp = 40

    ruleNames =  [ "program", "statement", "loopStatements", "variableDeclarationOrAssignment", 
                   "matrixExpression", "matrixAtom", "matrixConstruction", 
                   "row", "value", "stringExpression", "expression", "scopedIdentifier", 
                   "typeAnnotation", "functionDeclaration", "parameter", 
                   "typedParameter", "returnStatement", "functionCall", 
                   "argumentList", "builtInFunctions", "ifStatement", "loopIfStatement", 
                   "loopStatement", "forLoop", "forInit", "forUpdate", "forBody", 
                   "whileLoop", "displayStatement", "blockStatement", "numExpression", 
                   "term", "factor", "operation", "reassignment", "boolExpression", 
                   "boolOrExpression", "boolAndExpression", "boolNotExpression", 
                   "boolPrimary", "comparisonOp" ]

    EOF = Token.EOF
    START_PROGRAM=1
    END_PROGRAM=2
    DEFINE_FUNCTION=3
    END_FUNCTION=4
    RETURN=5
    CALL=6
    SET=7
    TO=8
    DISPLAY=9
    IF=10
    ELSE_IF=11
    ELSE=12
    END_IF=13
    FOR=14
    FROM=15
    IN=16
    END_FOR=17
    BREAK=18
    WHILE=19
    END_WHILE=20
    INVERT_MATRIX=21
    TRANSPOSITION=22
    PARENT_SCOPE=23
    DCOLON=24
    PLUS=25
    MINUS=26
    MULTIPLY=27
    DIVIDED_BY=28
    MODULO=29
    EQUALS=30
    GREATER_THAN=31
    LESS_THAN=32
    GREATER_EQUAL=33
    LESS_EQUAL=34
    ADD_TO=35
    SUBTRACT_FROM=36
    INCREMENT=37
    DECREMENT=38
    TIMES=39
    DIVIDE_FROM=40
    NOT_EQUALS=41
    AND=42
    OR=43
    NOT=44
    SEMICOLON=45
    COMMA=46
    COLON=47
    DOT=48
    QUOTE=49
    LBRACK=50
    RBRACK=51
    LBRACE=52
    RBRACE=53
    LPAREN=54
    RPAREN=55
    NUMBER=56
    STRING=57
    TYPE_INT=58
    TYPE_STRING=59
    TYPE_BOOL=60
    TYPE_FLOAT=61
    TYPE_MATRIX=62
    TYPE_VOID=63
    TRUE_VALUE=64
    FALSE_VALUE=65
    POWER_FUNC=66
    SIN_FUNC=67
    COS_FUNC=68
    TAN_FUNC=69
    CTAN_FUNC=70
    IDENTIFIER=71
    WS=72
    COMMENT=73

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def START_PROGRAM(self):
            return self.getToken(EnglishLangParser.START_PROGRAM, 0)

        def END_PROGRAM(self):
            return self.getToken(EnglishLangParser.END_PROGRAM, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = EnglishLangParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82
            self.match(EnglishLangParser.START_PROGRAM)
            self.state = 84 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 83
                self.statement()
                self.state = 86 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599627912936) != 0) or _la==71):
                    break

            self.state = 88
            self.match(EnglishLangParser.END_PROGRAM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclarationOrAssignment(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationOrAssignmentContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(EnglishLangParser.ReassignmentContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionDeclarationContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionCallContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.ReturnStatementContext,0)


        def displayStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.DisplayStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.IfStatementContext,0)


        def loopStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.LoopStatementContext,0)


        def forLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.ForLoopContext,0)


        def whileLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.WhileLoopContext,0)


        def blockStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.BlockStatementContext,0)


        def operation(self):
            return self.getTypedRuleContext(EnglishLangParser.OperationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = EnglishLangParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 102
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 90
                self.variableDeclarationOrAssignment()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 91
                self.reassignment()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 92
                self.functionDeclaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 93
                self.functionCall()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 94
                self.returnStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 95
                self.displayStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 96
                self.ifStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 97
                self.loopStatement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 98
                self.forLoop()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 99
                self.whileLoop()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 100
                self.blockStatement()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 101
                self.operation()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopStatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.LoopStatementContext,0)


        def variableDeclarationOrAssignment(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationOrAssignmentContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(EnglishLangParser.ReassignmentContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionDeclarationContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.ReturnStatementContext,0)


        def loopIfStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.LoopIfStatementContext,0)


        def blockStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.BlockStatementContext,0)


        def BREAK(self):
            return self.getToken(EnglishLangParser.BREAK, 0)

        def displayStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.DisplayStatementContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_loopStatements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopStatements" ):
                listener.enterLoopStatements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopStatements" ):
                listener.exitLoopStatements(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopStatements" ):
                return visitor.visitLoopStatements(self)
            else:
                return visitor.visitChildren(self)




    def loopStatements(self):

        localctx = EnglishLangParser.LoopStatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_loopStatements)
        try:
            self.state = 113
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 104
                self.loopStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 105
                self.variableDeclarationOrAssignment()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 106
                self.reassignment()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 107
                self.functionDeclaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 108
                self.returnStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 109
                self.loopIfStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 110
                self.blockStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 111
                self.match(EnglishLangParser.BREAK)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 112
                self.displayStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationOrAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(EnglishLangParser.SET, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def TO(self):
            return self.getToken(EnglishLangParser.TO, 0)

        def expression(self):
            return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,0)


        def typeAnnotation(self):
            return self.getTypedRuleContext(EnglishLangParser.TypeAnnotationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_variableDeclarationOrAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclarationOrAssignment" ):
                listener.enterVariableDeclarationOrAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclarationOrAssignment" ):
                listener.exitVariableDeclarationOrAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclarationOrAssignment" ):
                return visitor.visitVariableDeclarationOrAssignment(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclarationOrAssignment(self):

        localctx = EnglishLangParser.VariableDeclarationOrAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_variableDeclarationOrAssignment)
        self._la = 0 # Token type
        try:
            self.state = 125
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7]:
                self.enterOuterAlt(localctx, 1)
                self.state = 115
                self.match(EnglishLangParser.SET)
                self.state = 116
                self.match(EnglishLangParser.IDENTIFIER)
                self.state = 117
                self.match(EnglishLangParser.TO)
                self.state = 118
                self.expression()
                self.state = 120
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 8935141660703064064) != 0):
                    self.state = 119
                    self.typeAnnotation()


                pass
            elif token in [71]:
                self.enterOuterAlt(localctx, 2)
                self.state = 122
                self.match(EnglishLangParser.IDENTIFIER)
                self.state = 123
                self.match(EnglishLangParser.TO)
                self.state = 124
                self.expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def matrixAtom(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixAtomContext,0)


        def INVERT_MATRIX(self):
            return self.getToken(EnglishLangParser.INVERT_MATRIX, 0)

        def TRANSPOSITION(self):
            return self.getToken(EnglishLangParser.TRANSPOSITION, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_matrixExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixExpression" ):
                listener.enterMatrixExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixExpression" ):
                listener.exitMatrixExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixExpression" ):
                return visitor.visitMatrixExpression(self)
            else:
                return visitor.visitChildren(self)




    def matrixExpression(self):

        localctx = EnglishLangParser.MatrixExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_matrixExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==21:
                self.state = 127
                self.match(EnglishLangParser.INVERT_MATRIX)


            self.state = 130
            self.matrixAtom()
            self.state = 132
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 131
                self.match(EnglishLangParser.TRANSPOSITION)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixAtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def matrixConstruction(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixConstructionContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_matrixAtom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixAtom" ):
                listener.enterMatrixAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixAtom" ):
                listener.exitMatrixAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixAtom" ):
                return visitor.visitMatrixAtom(self)
            else:
                return visitor.visitChildren(self)




    def matrixAtom(self):

        localctx = EnglishLangParser.MatrixAtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_matrixAtom)
        try:
            self.state = 136
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [71]:
                self.enterOuterAlt(localctx, 1)
                self.state = 134
                self.match(EnglishLangParser.IDENTIFIER)
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 2)
                self.state = 135
                self.matrixConstruction()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixConstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACK(self):
            return self.getToken(EnglishLangParser.LBRACK, 0)

        def row(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.RowContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.RowContext,i)


        def RBRACK(self):
            return self.getToken(EnglishLangParser.RBRACK, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.SEMICOLON)
            else:
                return self.getToken(EnglishLangParser.SEMICOLON, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_matrixConstruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixConstruction" ):
                listener.enterMatrixConstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixConstruction" ):
                listener.exitMatrixConstruction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixConstruction" ):
                return visitor.visitMatrixConstruction(self)
            else:
                return visitor.visitChildren(self)




    def matrixConstruction(self):

        localctx = EnglishLangParser.MatrixConstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_matrixConstruction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 138
            self.match(EnglishLangParser.LBRACK)
            self.state = 139
            self.row()
            self.state = 144
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==45:
                self.state = 140
                self.match(EnglishLangParser.SEMICOLON)
                self.state = 141
                self.row()
                self.state = 146
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 147
            self.match(EnglishLangParser.RBRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.ValueContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.ValueContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_row

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRow" ):
                listener.enterRow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRow" ):
                listener.exitRow(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRow" ):
                return visitor.visitRow(self)
            else:
                return visitor.visitChildren(self)




    def row(self):

        localctx = EnglishLangParser.RowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_row)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 149
            self.value()
            self.state = 154
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==46:
                self.state = 150
                self.match(EnglishLangParser.COMMA)
                self.state = 151
                self.value()
                self.state = 156
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(EnglishLangParser.NUMBER, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue" ):
                listener.enterValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue" ):
                listener.exitValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValue" ):
                return visitor.visitValue(self)
            else:
                return visitor.visitChildren(self)




    def value(self):

        localctx = EnglishLangParser.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            _la = self._input.LA(1)
            if not(_la==56 or _la==71):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.STRING)
            else:
                return self.getToken(EnglishLangParser.STRING, i)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.IDENTIFIER)
            else:
                return self.getToken(EnglishLangParser.IDENTIFIER, i)

        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.PLUS)
            else:
                return self.getToken(EnglishLangParser.PLUS, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_stringExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringExpression" ):
                listener.enterStringExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringExpression" ):
                listener.exitStringExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringExpression" ):
                return visitor.visitStringExpression(self)
            else:
                return visitor.visitChildren(self)




    def stringExpression(self):

        localctx = EnglishLangParser.StringExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_stringExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 159
            _la = self._input.LA(1)
            if not(_la==57 or _la==71):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==25:
                self.state = 160
                self.match(EnglishLangParser.PLUS)
                self.state = 161
                _la = self._input.LA(1)
                if not(_la==57 or _la==71):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 166
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionCall(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionCallContext,0)


        def builtInFunctions(self):
            return self.getTypedRuleContext(EnglishLangParser.BuiltInFunctionsContext,0)


        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)


        def matrixExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixExpressionContext,0)


        def stringExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.StringExpressionContext,0)


        def NUMBER(self):
            return self.getToken(EnglishLangParser.NUMBER, 0)

        def STRING(self):
            return self.getToken(EnglishLangParser.STRING, 0)

        def scopedIdentifier(self):
            return self.getTypedRuleContext(EnglishLangParser.ScopedIdentifierContext,0)


        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,0)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = EnglishLangParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_expression)
        try:
            self.state = 181
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 167
                self.functionCall()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 168
                self.builtInFunctions()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 169
                self.numExpression(0)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 170
                self.boolExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 171
                self.matrixExpression()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 172
                self.stringExpression()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 173
                self.match(EnglishLangParser.NUMBER)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 174
                self.match(EnglishLangParser.STRING)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 175
                self.scopedIdentifier()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 176
                self.match(EnglishLangParser.IDENTIFIER)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 177
                self.match(EnglishLangParser.LPAREN)
                self.state = 178
                self.expression()
                self.state = 179
                self.match(EnglishLangParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScopedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def PARENT_SCOPE(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.PARENT_SCOPE)
            else:
                return self.getToken(EnglishLangParser.PARENT_SCOPE, i)

        def DCOLON(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.DCOLON)
            else:
                return self.getToken(EnglishLangParser.DCOLON, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_scopedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScopedIdentifier" ):
                listener.enterScopedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScopedIdentifier" ):
                listener.exitScopedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScopedIdentifier" ):
                return visitor.visitScopedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def scopedIdentifier(self):

        localctx = EnglishLangParser.ScopedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_scopedIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 183
                self.match(EnglishLangParser.PARENT_SCOPE)
                self.state = 184
                self.match(EnglishLangParser.DCOLON)
                self.state = 187 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==23):
                    break

            self.state = 189
            self.match(EnglishLangParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeAnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE_STRING(self):
            return self.getToken(EnglishLangParser.TYPE_STRING, 0)

        def TYPE_INT(self):
            return self.getToken(EnglishLangParser.TYPE_INT, 0)

        def TYPE_FLOAT(self):
            return self.getToken(EnglishLangParser.TYPE_FLOAT, 0)

        def TYPE_BOOL(self):
            return self.getToken(EnglishLangParser.TYPE_BOOL, 0)

        def TYPE_MATRIX(self):
            return self.getToken(EnglishLangParser.TYPE_MATRIX, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_typeAnnotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeAnnotation" ):
                listener.enterTypeAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeAnnotation" ):
                listener.exitTypeAnnotation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeAnnotation" ):
                return visitor.visitTypeAnnotation(self)
            else:
                return visitor.visitChildren(self)




    def typeAnnotation(self):

        localctx = EnglishLangParser.TypeAnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_typeAnnotation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 8935141660703064064) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE_FUNCTION(self):
            return self.getToken(EnglishLangParser.DEFINE_FUNCTION, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def blockStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.BlockStatementContext,0)


        def END_FUNCTION(self):
            return self.getToken(EnglishLangParser.END_FUNCTION, 0)

        def parameter(self):
            return self.getTypedRuleContext(EnglishLangParser.ParameterContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_functionDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDeclaration" ):
                listener.enterFunctionDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDeclaration" ):
                listener.exitFunctionDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDeclaration" ):
                return visitor.visitFunctionDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def functionDeclaration(self):

        localctx = EnglishLangParser.FunctionDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_functionDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(EnglishLangParser.DEFINE_FUNCTION)
            self.state = 194
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 195
            self.match(EnglishLangParser.LPAREN)
            self.state = 197
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==71:
                self.state = 196
                self.parameter()


            self.state = 199
            self.match(EnglishLangParser.RPAREN)
            self.state = 200
            self.blockStatement()
            self.state = 201
            self.match(EnglishLangParser.END_FUNCTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typedParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.TypedParameterContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.TypedParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = EnglishLangParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_parameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self.typedParameter()
            self.state = 208
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==46:
                self.state = 204
                self.match(EnglishLangParser.COMMA)
                self.state = 205
                self.typedParameter()
                self.state = 210
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypedParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def typeAnnotation(self):
            return self.getTypedRuleContext(EnglishLangParser.TypeAnnotationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_typedParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypedParameter" ):
                listener.enterTypedParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypedParameter" ):
                listener.exitTypedParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypedParameter" ):
                return visitor.visitTypedParameter(self)
            else:
                return visitor.visitChildren(self)




    def typedParameter(self):

        localctx = EnglishLangParser.TypedParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_typedParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 213
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 8935141660703064064) != 0):
                self.state = 212
                self.typeAnnotation()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(EnglishLangParser.RETURN, 0)

        def expression(self):
            return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_returnStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStatement" ):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)




    def returnStatement(self):

        localctx = EnglishLangParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 215
            self.match(EnglishLangParser.RETURN)
            self.state = 216
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def CALL(self):
            return self.getToken(EnglishLangParser.CALL, 0)

        def argumentList(self):
            return self.getTypedRuleContext(EnglishLangParser.ArgumentListContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = EnglishLangParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_functionCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 218
                self.match(EnglishLangParser.CALL)


            self.state = 221
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 222
            self.match(EnglishLangParser.LPAREN)
            self.state = 224
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 235330672827301952) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 255) != 0):
                self.state = 223
                self.argumentList()


            self.state = 226
            self.match(EnglishLangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentList" ):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)




    def argumentList(self):

        localctx = EnglishLangParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 228
            self.expression()
            self.state = 233
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==46:
                self.state = 229
                self.match(EnglishLangParser.COMMA)
                self.state = 230
                self.expression()
                self.state = 235
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BuiltInFunctionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POWER_FUNC(self):
            return self.getToken(EnglishLangParser.POWER_FUNC, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def numExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.NumExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,i)


        def COMMA(self):
            return self.getToken(EnglishLangParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def SIN_FUNC(self):
            return self.getToken(EnglishLangParser.SIN_FUNC, 0)

        def COS_FUNC(self):
            return self.getToken(EnglishLangParser.COS_FUNC, 0)

        def TAN_FUNC(self):
            return self.getToken(EnglishLangParser.TAN_FUNC, 0)

        def CTAN_FUNC(self):
            return self.getToken(EnglishLangParser.CTAN_FUNC, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_builtInFunctions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBuiltInFunctions" ):
                listener.enterBuiltInFunctions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBuiltInFunctions" ):
                listener.exitBuiltInFunctions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBuiltInFunctions" ):
                return visitor.visitBuiltInFunctions(self)
            else:
                return visitor.visitChildren(self)




    def builtInFunctions(self):

        localctx = EnglishLangParser.BuiltInFunctionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_builtInFunctions)
        self._la = 0 # Token type
        try:
            self.state = 248
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [66]:
                self.enterOuterAlt(localctx, 1)
                self.state = 236
                self.match(EnglishLangParser.POWER_FUNC)
                self.state = 237
                self.match(EnglishLangParser.LPAREN)
                self.state = 238
                self.numExpression(0)
                self.state = 239
                self.match(EnglishLangParser.COMMA)
                self.state = 240
                self.numExpression(0)
                self.state = 241
                self.match(EnglishLangParser.RPAREN)
                pass
            elif token in [67, 68, 69, 70]:
                self.enterOuterAlt(localctx, 2)
                self.state = 243
                _la = self._input.LA(1)
                if not(((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & 15) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 244
                self.match(EnglishLangParser.LPAREN)
                self.state = 245
                self.numExpression(0)
                self.state = 246
                self.match(EnglishLangParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(EnglishLangParser.IF, 0)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.LPAREN)
            else:
                return self.getToken(EnglishLangParser.LPAREN, i)

        def boolExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,i)


        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.RPAREN)
            else:
                return self.getToken(EnglishLangParser.RPAREN, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def blockStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BlockStatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BlockStatementContext,i)


        def ELSE_IF(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.ELSE_IF)
            else:
                return self.getToken(EnglishLangParser.ELSE_IF, i)

        def ELSE(self):
            return self.getToken(EnglishLangParser.ELSE, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStatement(self):

        localctx = EnglishLangParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_ifStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.match(EnglishLangParser.IF)
            self.state = 251
            self.match(EnglishLangParser.LPAREN)
            self.state = 252
            self.boolExpression()
            self.state = 253
            self.match(EnglishLangParser.RPAREN)
            self.state = 256
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.state = 254
                self.statement()
                pass

            elif la_ == 2:
                self.state = 255
                self.blockStatement()
                pass


            self.state = 268
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,22,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 258
                    self.match(EnglishLangParser.ELSE_IF)
                    self.state = 259
                    self.match(EnglishLangParser.LPAREN)
                    self.state = 260
                    self.boolExpression()
                    self.state = 261
                    self.match(EnglishLangParser.RPAREN)
                    self.state = 264
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
                    if la_ == 1:
                        self.state = 262
                        self.statement()
                        pass

                    elif la_ == 2:
                        self.state = 263
                        self.blockStatement()
                        pass

             
                self.state = 270
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,22,self._ctx)

            self.state = 276
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.state = 271
                self.match(EnglishLangParser.ELSE)
                self.state = 274
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
                if la_ == 1:
                    self.state = 272
                    self.statement()
                    pass

                elif la_ == 2:
                    self.state = 273
                    self.blockStatement()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopIfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(EnglishLangParser.IF, 0)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.LPAREN)
            else:
                return self.getToken(EnglishLangParser.LPAREN, i)

        def boolExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,i)


        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.RPAREN)
            else:
                return self.getToken(EnglishLangParser.RPAREN, i)

        def LBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.LBRACE)
            else:
                return self.getToken(EnglishLangParser.LBRACE, i)

        def RBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.RBRACE)
            else:
                return self.getToken(EnglishLangParser.RBRACE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def ELSE_IF(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.ELSE_IF)
            else:
                return self.getToken(EnglishLangParser.ELSE_IF, i)

        def ELSE(self):
            return self.getToken(EnglishLangParser.ELSE, 0)

        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.LoopStatementsContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_loopIfStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopIfStatement" ):
                listener.enterLoopIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopIfStatement" ):
                listener.exitLoopIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopIfStatement" ):
                return visitor.visitLoopIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def loopIfStatement(self):

        localctx = EnglishLangParser.LoopIfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_loopIfStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 278
            self.match(EnglishLangParser.IF)
            self.state = 279
            self.match(EnglishLangParser.LPAREN)
            self.state = 280
            self.boolExpression()
            self.state = 281
            self.match(EnglishLangParser.RPAREN)
            self.state = 291
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.state = 282
                self.match(EnglishLangParser.LBRACE)
                self.state = 284 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 283
                    self.loopStatements()
                    self.state = 286 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599628175016) != 0) or _la==71):
                        break

                self.state = 288
                self.match(EnglishLangParser.RBRACE)
                pass

            elif la_ == 2:
                self.state = 290
                self.statement()
                pass


            self.state = 310
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 293
                self.match(EnglishLangParser.ELSE_IF)
                self.state = 294
                self.match(EnglishLangParser.LPAREN)
                self.state = 295
                self.boolExpression()
                self.state = 296
                self.match(EnglishLangParser.RPAREN)
                self.state = 306
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
                if la_ == 1:
                    self.state = 297
                    self.match(EnglishLangParser.LBRACE)
                    self.state = 299 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 298
                        self.loopStatements()
                        self.state = 301 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599628175016) != 0) or _la==71):
                            break

                    self.state = 303
                    self.match(EnglishLangParser.RBRACE)
                    pass

                elif la_ == 2:
                    self.state = 305
                    self.statement()
                    pass


                self.state = 312
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 325
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==12:
                self.state = 313
                self.match(EnglishLangParser.ELSE)
                self.state = 323
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
                if la_ == 1:
                    self.state = 314
                    self.match(EnglishLangParser.LBRACE)
                    self.state = 316 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 315
                        self.loopStatements()
                        self.state = 318 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599628175016) != 0) or _la==71):
                            break

                    self.state = 320
                    self.match(EnglishLangParser.RBRACE)
                    pass

                elif la_ == 2:
                    self.state = 322
                    self.statement()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.ForLoopContext,0)


        def whileLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.WhileLoopContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_loopStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopStatement" ):
                listener.enterLoopStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopStatement" ):
                listener.exitLoopStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopStatement" ):
                return visitor.visitLoopStatement(self)
            else:
                return visitor.visitChildren(self)




    def loopStatement(self):

        localctx = EnglishLangParser.LoopStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_loopStatement)
        try:
            self.state = 329
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [14]:
                self.enterOuterAlt(localctx, 1)
                self.state = 327
                self.forLoop()
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 2)
                self.state = 328
                self.whileLoop()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForLoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.cond = None # BoolExpressionContext

        def FOR(self):
            return self.getToken(EnglishLangParser.FOR, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.SEMICOLON)
            else:
                return self.getToken(EnglishLangParser.SEMICOLON, i)

        def forUpdate(self):
            return self.getTypedRuleContext(EnglishLangParser.ForUpdateContext,0)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def forBody(self):
            return self.getTypedRuleContext(EnglishLangParser.ForBodyContext,0)


        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)


        def forInit(self):
            return self.getTypedRuleContext(EnglishLangParser.ForInitContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_forLoop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForLoop" ):
                listener.enterForLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForLoop" ):
                listener.exitForLoop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForLoop" ):
                return visitor.visitForLoop(self)
            else:
                return visitor.visitChildren(self)




    def forLoop(self):

        localctx = EnglishLangParser.ForLoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_forLoop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 331
            self.match(EnglishLangParser.FOR)
            self.state = 332
            self.match(EnglishLangParser.LPAREN)
            self.state = 334
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7 or _la==71:
                self.state = 333
                self.forInit()


            self.state = 336
            self.match(EnglishLangParser.SEMICOLON)
            self.state = 337
            localctx.cond = self.boolExpression()
            self.state = 338
            self.match(EnglishLangParser.SEMICOLON)
            self.state = 339
            self.forUpdate()
            self.state = 340
            self.match(EnglishLangParser.RPAREN)
            self.state = 341
            self.forBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForInitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def variableDeclarationOrAssignment(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationOrAssignmentContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_forInit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForInit" ):
                listener.enterForInit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForInit" ):
                listener.exitForInit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForInit" ):
                return visitor.visitForInit(self)
            else:
                return visitor.visitChildren(self)




    def forInit(self):

        localctx = EnglishLangParser.ForInitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_forInit)
        try:
            self.state = 345
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 343
                self.match(EnglishLangParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 344
                self.variableDeclarationOrAssignment()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForUpdateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclarationOrAssignment(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationOrAssignmentContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(EnglishLangParser.ReassignmentContext,0)


        def operation(self):
            return self.getTypedRuleContext(EnglishLangParser.OperationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_forUpdate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForUpdate" ):
                listener.enterForUpdate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForUpdate" ):
                listener.exitForUpdate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForUpdate" ):
                return visitor.visitForUpdate(self)
            else:
                return visitor.visitChildren(self)




    def forUpdate(self):

        localctx = EnglishLangParser.ForUpdateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_forUpdate)
        try:
            self.state = 350
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 347
                self.variableDeclarationOrAssignment()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 348
                self.reassignment()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 349
                self.operation()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.LoopStatementsContext,i)


        def statement(self):
            return self.getTypedRuleContext(EnglishLangParser.StatementContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_forBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForBody" ):
                listener.enterForBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForBody" ):
                listener.exitForBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForBody" ):
                return visitor.visitForBody(self)
            else:
                return visitor.visitChildren(self)




    def forBody(self):

        localctx = EnglishLangParser.ForBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_forBody)
        self._la = 0 # Token type
        try:
            self.state = 361
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 352
                self.match(EnglishLangParser.LBRACE)
                self.state = 354 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 353
                    self.loopStatements()
                    self.state = 356 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599628175016) != 0) or _la==71):
                        break

                self.state = 358
                self.match(EnglishLangParser.RBRACE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 360
                self.statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileLoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(EnglishLangParser.WHILE, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def statement(self):
            return self.getTypedRuleContext(EnglishLangParser.StatementContext,0)


        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.LoopStatementsContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_whileLoop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileLoop" ):
                listener.enterWhileLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileLoop" ):
                listener.exitWhileLoop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileLoop" ):
                return visitor.visitWhileLoop(self)
            else:
                return visitor.visitChildren(self)




    def whileLoop(self):

        localctx = EnglishLangParser.WhileLoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_whileLoop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 363
            self.match(EnglishLangParser.WHILE)
            self.state = 364
            self.match(EnglishLangParser.LPAREN)
            self.state = 365
            self.boolExpression()
            self.state = 366
            self.match(EnglishLangParser.RPAREN)
            self.state = 376
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
            if la_ == 1:
                self.state = 367
                self.match(EnglishLangParser.LBRACE)
                self.state = 369 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 368
                    self.loopStatements()
                    self.state = 371 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599628175016) != 0) or _la==71):
                        break

                self.state = 373
                self.match(EnglishLangParser.RBRACE)
                pass

            elif la_ == 2:
                self.state = 375
                self.statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DisplayStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISPLAY(self):
            return self.getToken(EnglishLangParser.DISPLAY, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_displayStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDisplayStatement" ):
                listener.enterDisplayStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDisplayStatement" ):
                listener.exitDisplayStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisplayStatement" ):
                return visitor.visitDisplayStatement(self)
            else:
                return visitor.visitChildren(self)




    def displayStatement(self):

        localctx = EnglishLangParser.DisplayStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_displayStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 378
            self.match(EnglishLangParser.DISPLAY)
            self.state = 379
            self.expression()
            self.state = 384
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==46:
                self.state = 380
                self.match(EnglishLangParser.COMMA)
                self.state = 381
                self.expression()
                self.state = 386
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_blockStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlockStatement" ):
                listener.enterBlockStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlockStatement" ):
                listener.exitBlockStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlockStatement" ):
                return visitor.visitBlockStatement(self)
            else:
                return visitor.visitChildren(self)




    def blockStatement(self):

        localctx = EnglishLangParser.BlockStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_blockStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 387
            self.match(EnglishLangParser.LBRACE)
            self.state = 391
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 4503599627912936) != 0) or _la==71:
                self.state = 388
                self.statement()
                self.state = 393
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 394
            self.match(EnglishLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self):
            return self.getTypedRuleContext(EnglishLangParser.TermContext,0)


        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def PLUS(self):
            return self.getToken(EnglishLangParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(EnglishLangParser.MINUS, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_numExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumExpression" ):
                listener.enterNumExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumExpression" ):
                listener.exitNumExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumExpression" ):
                return visitor.visitNumExpression(self)
            else:
                return visitor.visitChildren(self)



    def numExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = EnglishLangParser.NumExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 60
        self.enterRecursionRule(localctx, 60, self.RULE_numExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 397
            self.term(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 404
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,43,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = EnglishLangParser.NumExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_numExpression)
                    self.state = 399
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 400
                    _la = self._input.LA(1)
                    if not(_la==25 or _la==26):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 401
                    self.term(0) 
                self.state = 406
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,43,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self):
            return self.getTypedRuleContext(EnglishLangParser.FactorContext,0)


        def term(self):
            return self.getTypedRuleContext(EnglishLangParser.TermContext,0)


        def MULTIPLY(self):
            return self.getToken(EnglishLangParser.MULTIPLY, 0)

        def DIVIDED_BY(self):
            return self.getToken(EnglishLangParser.DIVIDED_BY, 0)

        def MODULO(self):
            return self.getToken(EnglishLangParser.MODULO, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm" ):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)



    def term(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = EnglishLangParser.TermContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 62
        self.enterRecursionRule(localctx, 62, self.RULE_term, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 408
            self.factor()
            self._ctx.stop = self._input.LT(-1)
            self.state = 415
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,44,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = EnglishLangParser.TermContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_term)
                    self.state = 410
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 411
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 939524096) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 412
                    self.factor() 
                self.state = 417
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,44,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class FactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return EnglishLangParser.RULE_factor

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class CastExpressionContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)
        def typeAnnotation(self):
            return self.getTypedRuleContext(EnglishLangParser.TypeAnnotationContext,0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)
        def factor(self):
            return self.getTypedRuleContext(EnglishLangParser.FactorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCastExpression" ):
                listener.enterCastExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCastExpression" ):
                listener.exitCastExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCastExpression" ):
                return visitor.visitCastExpression(self)
            else:
                return visitor.visitChildren(self)


    class FactorOperationContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def operation(self):
            return self.getTypedRuleContext(EnglishLangParser.OperationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorOperation" ):
                listener.enterFactorOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorOperation" ):
                listener.exitFactorOperation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorOperation" ):
                return visitor.visitFactorOperation(self)
            else:
                return visitor.visitChildren(self)


    class UnaryPlusContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PLUS(self):
            return self.getToken(EnglishLangParser.PLUS, 0)
        def factor(self):
            return self.getTypedRuleContext(EnglishLangParser.FactorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryPlus" ):
                listener.enterUnaryPlus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryPlus" ):
                listener.exitUnaryPlus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryPlus" ):
                return visitor.visitUnaryPlus(self)
            else:
                return visitor.visitChildren(self)


    class FactorIdentifierContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorIdentifier" ):
                listener.enterFactorIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorIdentifier" ):
                listener.exitFactorIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorIdentifier" ):
                return visitor.visitFactorIdentifier(self)
            else:
                return visitor.visitChildren(self)


    class FactorFunctionCallContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def functionCall(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionCallContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorFunctionCall" ):
                listener.enterFactorFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorFunctionCall" ):
                listener.exitFactorFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorFunctionCall" ):
                return visitor.visitFactorFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class FactorNumberContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(EnglishLangParser.NUMBER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorNumber" ):
                listener.enterFactorNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorNumber" ):
                listener.exitFactorNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorNumber" ):
                return visitor.visitFactorNumber(self)
            else:
                return visitor.visitChildren(self)


    class UnaryMinusContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MINUS(self):
            return self.getToken(EnglishLangParser.MINUS, 0)
        def factor(self):
            return self.getTypedRuleContext(EnglishLangParser.FactorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinus" ):
                listener.enterUnaryMinus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinus" ):
                listener.exitUnaryMinus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMinus" ):
                return visitor.visitUnaryMinus(self)
            else:
                return visitor.visitChildren(self)


    class FactorParensContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)
        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorParens" ):
                listener.enterFactorParens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorParens" ):
                listener.exitFactorParens(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorParens" ):
                return visitor.visitFactorParens(self)
            else:
                return visitor.visitChildren(self)


    class FactorscopedIdentifierContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def scopedIdentifier(self):
            return self.getTypedRuleContext(EnglishLangParser.ScopedIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorscopedIdentifier" ):
                listener.enterFactorscopedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorscopedIdentifier" ):
                listener.exitFactorscopedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorscopedIdentifier" ):
                return visitor.visitFactorscopedIdentifier(self)
            else:
                return visitor.visitChildren(self)


    class FactorStringContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(EnglishLangParser.STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorString" ):
                listener.enterFactorString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorString" ):
                listener.exitFactorString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorString" ):
                return visitor.visitFactorString(self)
            else:
                return visitor.visitChildren(self)



    def factor(self):

        localctx = EnglishLangParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_factor)
        try:
            self.state = 437
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
                localctx = EnglishLangParser.UnaryPlusContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 418
                self.match(EnglishLangParser.PLUS)
                self.state = 419
                self.factor()
                pass

            elif la_ == 2:
                localctx = EnglishLangParser.UnaryMinusContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 420
                self.match(EnglishLangParser.MINUS)
                self.state = 421
                self.factor()
                pass

            elif la_ == 3:
                localctx = EnglishLangParser.FactorFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 422
                self.functionCall()
                pass

            elif la_ == 4:
                localctx = EnglishLangParser.FactorNumberContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 423
                self.match(EnglishLangParser.NUMBER)
                pass

            elif la_ == 5:
                localctx = EnglishLangParser.FactorscopedIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 424
                self.scopedIdentifier()
                pass

            elif la_ == 6:
                localctx = EnglishLangParser.FactorIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 425
                self.match(EnglishLangParser.IDENTIFIER)
                pass

            elif la_ == 7:
                localctx = EnglishLangParser.FactorStringContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 426
                self.match(EnglishLangParser.STRING)
                pass

            elif la_ == 8:
                localctx = EnglishLangParser.FactorOperationContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 427
                self.operation()
                pass

            elif la_ == 9:
                localctx = EnglishLangParser.FactorParensContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 428
                self.match(EnglishLangParser.LPAREN)
                self.state = 429
                self.numExpression(0)
                self.state = 430
                self.match(EnglishLangParser.RPAREN)
                pass

            elif la_ == 10:
                localctx = EnglishLangParser.CastExpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 432
                self.match(EnglishLangParser.LPAREN)
                self.state = 433
                self.typeAnnotation()
                self.state = 434
                self.match(EnglishLangParser.RPAREN)
                self.state = 435
                self.factor()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def INCREMENT(self):
            return self.getToken(EnglishLangParser.INCREMENT, 0)

        def DECREMENT(self):
            return self.getToken(EnglishLangParser.DECREMENT, 0)

        def SEMICOLON(self):
            return self.getToken(EnglishLangParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_operation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperation" ):
                listener.enterOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperation" ):
                listener.exitOperation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperation" ):
                return visitor.visitOperation(self)
            else:
                return visitor.visitChildren(self)




    def operation(self):

        localctx = EnglishLangParser.OperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_operation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 439
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 440
            _la = self._input.LA(1)
            if not(_la==37 or _la==38):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 442
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                self.state = 441
                self.match(EnglishLangParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReassignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def SEMICOLON(self):
            return self.getToken(EnglishLangParser.SEMICOLON, 0)

        def SUBTRACT_FROM(self):
            return self.getToken(EnglishLangParser.SUBTRACT_FROM, 0)

        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def DIVIDE_FROM(self):
            return self.getToken(EnglishLangParser.DIVIDE_FROM, 0)

        def TIMES(self):
            return self.getToken(EnglishLangParser.TIMES, 0)

        def ADD_TO(self):
            return self.getToken(EnglishLangParser.ADD_TO, 0)

        def STRING(self):
            return self.getToken(EnglishLangParser.STRING, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_reassignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReassignment" ):
                listener.enterReassignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReassignment" ):
                listener.exitReassignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReassignment" ):
                return visitor.visitReassignment(self)
            else:
                return visitor.visitChildren(self)




    def reassignment(self):

        localctx = EnglishLangParser.ReassignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_reassignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 444
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 457
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [35]:
                self.state = 449
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
                if la_ == 1:
                    self.state = 445
                    self.match(EnglishLangParser.ADD_TO)
                    self.state = 446
                    self.match(EnglishLangParser.STRING)
                    pass

                elif la_ == 2:
                    self.state = 447
                    self.match(EnglishLangParser.ADD_TO)
                    self.state = 448
                    self.numExpression(0)
                    pass


                pass
            elif token in [36]:
                self.state = 451
                self.match(EnglishLangParser.SUBTRACT_FROM)
                self.state = 452
                self.numExpression(0)
                pass
            elif token in [40]:
                self.state = 453
                self.match(EnglishLangParser.DIVIDE_FROM)
                self.state = 454
                self.numExpression(0)
                pass
            elif token in [39]:
                self.state = 455
                self.match(EnglishLangParser.TIMES)
                self.state = 456
                self.numExpression(0)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 459
            self.match(EnglishLangParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolOrExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolOrExpressionContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_boolExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolExpression" ):
                listener.enterBoolExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolExpression" ):
                listener.exitBoolExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolExpression" ):
                return visitor.visitBoolExpression(self)
            else:
                return visitor.visitChildren(self)




    def boolExpression(self):

        localctx = EnglishLangParser.BoolExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_boolExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 461
            self.boolOrExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolOrExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return EnglishLangParser.RULE_boolOrExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicOrContext(BoolOrExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolOrExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolAndExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolAndExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolAndExpressionContext,i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.OR)
            else:
                return self.getToken(EnglishLangParser.OR, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicOr" ):
                listener.enterLogicOr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicOr" ):
                listener.exitLogicOr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicOr" ):
                return visitor.visitLogicOr(self)
            else:
                return visitor.visitChildren(self)



    def boolOrExpression(self):

        localctx = EnglishLangParser.BoolOrExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_boolOrExpression)
        self._la = 0 # Token type
        try:
            localctx = EnglishLangParser.LogicOrContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 463
            self.boolAndExpression()
            self.state = 468
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==43:
                self.state = 464
                self.match(EnglishLangParser.OR)
                self.state = 465
                self.boolAndExpression()
                self.state = 470
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolAndExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return EnglishLangParser.RULE_boolAndExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicAndContext(BoolAndExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolAndExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolNotExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolNotExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolNotExpressionContext,i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.AND)
            else:
                return self.getToken(EnglishLangParser.AND, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicAnd" ):
                listener.enterLogicAnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicAnd" ):
                listener.exitLogicAnd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicAnd" ):
                return visitor.visitLogicAnd(self)
            else:
                return visitor.visitChildren(self)



    def boolAndExpression(self):

        localctx = EnglishLangParser.BoolAndExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_boolAndExpression)
        self._la = 0 # Token type
        try:
            localctx = EnglishLangParser.LogicAndContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 471
            self.boolNotExpression()
            self.state = 476
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==42:
                self.state = 472
                self.match(EnglishLangParser.AND)
                self.state = 473
                self.boolNotExpression()
                self.state = 478
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolNotExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return EnglishLangParser.RULE_boolNotExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicPrimaryWrapContext(BoolNotExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolNotExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolPrimary(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolPrimaryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicPrimaryWrap" ):
                listener.enterLogicPrimaryWrap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicPrimaryWrap" ):
                listener.exitLogicPrimaryWrap(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicPrimaryWrap" ):
                return visitor.visitLogicPrimaryWrap(self)
            else:
                return visitor.visitChildren(self)


    class LogicNotContext(BoolNotExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolNotExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(EnglishLangParser.NOT, 0)
        def boolNotExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolNotExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicNot" ):
                listener.enterLogicNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicNot" ):
                listener.exitLogicNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicNot" ):
                return visitor.visitLogicNot(self)
            else:
                return visitor.visitChildren(self)



    def boolNotExpression(self):

        localctx = EnglishLangParser.BoolNotExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_boolNotExpression)
        try:
            self.state = 482
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [44]:
                localctx = EnglishLangParser.LogicNotContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 479
                self.match(EnglishLangParser.NOT)
                self.state = 480
                self.boolNotExpression()
                pass
            elif token in [6, 21, 23, 25, 26, 50, 54, 56, 57, 64, 65, 71]:
                localctx = EnglishLangParser.LogicPrimaryWrapContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 481
                self.boolPrimary()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolPrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return EnglishLangParser.RULE_boolPrimary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class StringComparisonContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def stringExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StringExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StringExpressionContext,i)

        def EQUALS(self):
            return self.getToken(EnglishLangParser.EQUALS, 0)
        def NOT_EQUALS(self):
            return self.getToken(EnglishLangParser.NOT_EQUALS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringComparison" ):
                listener.enterStringComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringComparison" ):
                listener.exitStringComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringComparison" ):
                return visitor.visitStringComparison(self)
            else:
                return visitor.visitChildren(self)


    class FalseLiteralContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FALSE_VALUE(self):
            return self.getToken(EnglishLangParser.FALSE_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFalseLiteral" ):
                listener.enterFalseLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFalseLiteral" ):
                listener.exitFalseLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFalseLiteral" ):
                return visitor.visitFalseLiteral(self)
            else:
                return visitor.visitChildren(self)


    class NumComparisonContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def numExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.NumExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,i)

        def comparisonOp(self):
            return self.getTypedRuleContext(EnglishLangParser.ComparisonOpContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumComparison" ):
                listener.enterNumComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumComparison" ):
                listener.exitNumComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumComparison" ):
                return visitor.visitNumComparison(self)
            else:
                return visitor.visitChildren(self)


    class LogicParenContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)
        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicParen" ):
                listener.enterLogicParen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicParen" ):
                listener.exitLogicParen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicParen" ):
                return visitor.visitLogicParen(self)
            else:
                return visitor.visitChildren(self)


    class TrueLiteralContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRUE_VALUE(self):
            return self.getToken(EnglishLangParser.TRUE_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrueLiteral" ):
                listener.enterTrueLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrueLiteral" ):
                listener.exitTrueLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrueLiteral" ):
                return visitor.visitTrueLiteral(self)
            else:
                return visitor.visitChildren(self)


    class LogicIdentifierContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicIdentifier" ):
                listener.enterLogicIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicIdentifier" ):
                listener.exitLogicIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicIdentifier" ):
                return visitor.visitLogicIdentifier(self)
            else:
                return visitor.visitChildren(self)


    class MatrixComparisonContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def matrixExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.MatrixExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.MatrixExpressionContext,i)

        def EQUALS(self):
            return self.getToken(EnglishLangParser.EQUALS, 0)
        def NOT_EQUALS(self):
            return self.getToken(EnglishLangParser.NOT_EQUALS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixComparison" ):
                listener.enterMatrixComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixComparison" ):
                listener.exitMatrixComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixComparison" ):
                return visitor.visitMatrixComparison(self)
            else:
                return visitor.visitChildren(self)



    def boolPrimary(self):

        localctx = EnglishLangParser.BoolPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_boolPrimary)
        self._la = 0 # Token type
        try:
            self.state = 503
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
            if la_ == 1:
                localctx = EnglishLangParser.NumComparisonContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 484
                self.numExpression(0)
                self.state = 485
                self.comparisonOp()
                self.state = 486
                self.numExpression(0)
                pass

            elif la_ == 2:
                localctx = EnglishLangParser.StringComparisonContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 488
                self.stringExpression()
                self.state = 489
                _la = self._input.LA(1)
                if not(_la==30 or _la==41):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 490
                self.stringExpression()
                pass

            elif la_ == 3:
                localctx = EnglishLangParser.MatrixComparisonContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 492
                self.matrixExpression()
                self.state = 493
                _la = self._input.LA(1)
                if not(_la==30 or _la==41):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 494
                self.matrixExpression()
                pass

            elif la_ == 4:
                localctx = EnglishLangParser.LogicParenContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 496
                self.match(EnglishLangParser.LPAREN)
                self.state = 497
                self.boolExpression()
                self.state = 498
                self.match(EnglishLangParser.RPAREN)
                pass

            elif la_ == 5:
                localctx = EnglishLangParser.TrueLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 500
                self.match(EnglishLangParser.TRUE_VALUE)
                pass

            elif la_ == 6:
                localctx = EnglishLangParser.FalseLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 501
                self.match(EnglishLangParser.FALSE_VALUE)
                pass

            elif la_ == 7:
                localctx = EnglishLangParser.LogicIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 502
                self.match(EnglishLangParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUALS(self):
            return self.getToken(EnglishLangParser.EQUALS, 0)

        def NOT_EQUALS(self):
            return self.getToken(EnglishLangParser.NOT_EQUALS, 0)

        def GREATER_THAN(self):
            return self.getToken(EnglishLangParser.GREATER_THAN, 0)

        def LESS_THAN(self):
            return self.getToken(EnglishLangParser.LESS_THAN, 0)

        def GREATER_EQUAL(self):
            return self.getToken(EnglishLangParser.GREATER_EQUAL, 0)

        def LESS_EQUAL(self):
            return self.getToken(EnglishLangParser.LESS_EQUAL, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_comparisonOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOp" ):
                listener.enterComparisonOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOp" ):
                listener.exitComparisonOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOp" ):
                return visitor.visitComparisonOp(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOp(self):

        localctx = EnglishLangParser.ComparisonOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_comparisonOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 505
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 2232309252096) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[30] = self.numExpression_sempred
        self._predicates[31] = self.term_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def numExpression_sempred(self, localctx:NumExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def term_sempred(self, localctx:TermContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 2)
         




