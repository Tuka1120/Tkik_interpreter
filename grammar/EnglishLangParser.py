# Generated from EnglishLangParser.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,72,487,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        1,0,1,0,4,0,83,8,0,11,0,12,0,84,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,3,1,100,8,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
        1,2,3,2,111,8,2,1,3,3,3,114,8,3,1,3,1,3,1,3,1,3,1,3,1,4,3,4,122,
        8,4,1,4,1,4,3,4,126,8,4,1,5,1,5,3,5,130,8,5,1,6,1,6,1,6,1,6,5,6,
        136,8,6,10,6,12,6,139,9,6,1,6,1,6,1,7,1,7,1,7,5,7,146,8,7,10,7,12,
        7,149,9,7,1,8,1,8,1,8,3,8,154,8,8,1,9,1,9,1,9,5,9,159,8,9,10,9,12,
        9,162,9,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,
        1,10,1,10,3,10,177,8,10,1,11,1,11,1,12,1,12,1,12,1,12,3,12,185,8,
        12,1,12,1,12,1,12,1,12,1,13,1,13,1,13,5,13,194,8,13,10,13,12,13,
        197,9,13,1,14,1,14,1,14,1,15,1,15,1,15,1,16,3,16,206,8,16,1,16,1,
        16,1,16,3,16,211,8,16,1,16,1,16,1,17,1,17,1,17,5,17,218,8,17,10,
        17,12,17,221,9,17,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,
        18,1,18,1,18,3,18,235,8,18,1,19,1,19,1,19,1,19,1,19,1,19,3,19,243,
        8,19,1,19,1,19,1,19,1,19,1,19,1,19,3,19,251,8,19,5,19,253,8,19,10,
        19,12,19,256,9,19,1,19,1,19,1,19,3,19,261,8,19,3,19,263,8,19,1,20,
        1,20,1,20,1,20,1,20,1,20,4,20,271,8,20,11,20,12,20,272,1,20,1,20,
        1,20,3,20,278,8,20,1,20,1,20,1,20,1,20,1,20,1,20,4,20,286,8,20,11,
        20,12,20,287,1,20,1,20,1,20,3,20,293,8,20,5,20,295,8,20,10,20,12,
        20,298,9,20,1,20,1,20,1,20,4,20,303,8,20,11,20,12,20,304,1,20,1,
        20,1,20,3,20,310,8,20,3,20,312,8,20,1,21,1,21,3,21,316,8,21,1,22,
        1,22,1,22,3,22,321,8,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,23,
        1,23,3,23,332,8,23,1,24,1,24,1,24,3,24,337,8,24,1,25,1,25,4,25,341,
        8,25,11,25,12,25,342,1,25,1,25,1,25,3,25,348,8,25,1,26,1,26,1,26,
        1,26,1,26,1,26,4,26,356,8,26,11,26,12,26,357,1,26,1,26,1,26,3,26,
        363,8,26,1,27,1,27,1,27,1,27,5,27,369,8,27,10,27,12,27,372,9,27,
        1,28,1,28,4,28,376,8,28,11,28,12,28,377,1,28,1,28,1,29,1,29,1,29,
        1,29,1,29,1,29,5,29,388,8,29,10,29,12,29,391,9,29,1,30,1,30,1,30,
        1,30,1,30,1,30,5,30,399,8,30,10,30,12,30,402,9,30,1,31,1,31,1,31,
        1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,3,31,417,8,31,
        1,32,1,32,1,32,3,32,422,8,32,1,33,1,33,1,33,1,33,1,33,3,33,429,8,
        33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,437,8,33,1,33,1,33,1,34,1,
        34,1,35,1,35,1,35,5,35,446,8,35,10,35,12,35,449,9,35,1,36,1,36,1,
        36,5,36,454,8,36,10,36,12,36,457,9,36,1,37,1,37,1,37,3,37,462,8,
        37,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,
        38,1,38,1,38,1,38,1,38,1,38,1,38,3,38,483,8,38,1,39,1,39,1,39,0,
        2,58,60,40,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
        40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,0,8,
        2,0,56,56,70,70,1,0,57,61,1,0,66,69,1,0,24,25,1,0,26,28,1,0,36,37,
        2,0,29,29,40,40,2,0,29,33,40,40,536,0,80,1,0,0,0,2,99,1,0,0,0,4,
        110,1,0,0,0,6,113,1,0,0,0,8,121,1,0,0,0,10,129,1,0,0,0,12,131,1,
        0,0,0,14,142,1,0,0,0,16,153,1,0,0,0,18,155,1,0,0,0,20,176,1,0,0,
        0,22,178,1,0,0,0,24,180,1,0,0,0,26,190,1,0,0,0,28,198,1,0,0,0,30,
        201,1,0,0,0,32,205,1,0,0,0,34,214,1,0,0,0,36,234,1,0,0,0,38,236,
        1,0,0,0,40,264,1,0,0,0,42,315,1,0,0,0,44,317,1,0,0,0,46,331,1,0,
        0,0,48,336,1,0,0,0,50,347,1,0,0,0,52,349,1,0,0,0,54,364,1,0,0,0,
        56,373,1,0,0,0,58,381,1,0,0,0,60,392,1,0,0,0,62,416,1,0,0,0,64,421,
        1,0,0,0,66,423,1,0,0,0,68,440,1,0,0,0,70,442,1,0,0,0,72,450,1,0,
        0,0,74,461,1,0,0,0,76,482,1,0,0,0,78,484,1,0,0,0,80,82,5,1,0,0,81,
        83,3,2,1,0,82,81,1,0,0,0,83,84,1,0,0,0,84,82,1,0,0,0,84,85,1,0,0,
        0,85,86,1,0,0,0,86,87,5,2,0,0,87,1,1,0,0,0,88,100,3,6,3,0,89,100,
        3,66,33,0,90,100,3,24,12,0,91,100,3,32,16,0,92,100,3,30,15,0,93,
        100,3,54,27,0,94,100,3,38,19,0,95,100,3,42,21,0,96,100,3,44,22,0,
        97,100,3,52,26,0,98,100,3,64,32,0,99,88,1,0,0,0,99,89,1,0,0,0,99,
        90,1,0,0,0,99,91,1,0,0,0,99,92,1,0,0,0,99,93,1,0,0,0,99,94,1,0,0,
        0,99,95,1,0,0,0,99,96,1,0,0,0,99,97,1,0,0,0,99,98,1,0,0,0,100,3,
        1,0,0,0,101,111,3,42,21,0,102,111,3,6,3,0,103,111,3,66,33,0,104,
        111,3,24,12,0,105,111,3,30,15,0,106,111,3,40,20,0,107,111,3,56,28,
        0,108,111,5,19,0,0,109,111,3,54,27,0,110,101,1,0,0,0,110,102,1,0,
        0,0,110,103,1,0,0,0,110,104,1,0,0,0,110,105,1,0,0,0,110,106,1,0,
        0,0,110,107,1,0,0,0,110,108,1,0,0,0,110,109,1,0,0,0,111,5,1,0,0,
        0,112,114,5,8,0,0,113,112,1,0,0,0,113,114,1,0,0,0,114,115,1,0,0,
        0,115,116,5,70,0,0,116,117,5,9,0,0,117,118,3,20,10,0,118,119,3,22,
        11,0,119,7,1,0,0,0,120,122,5,22,0,0,121,120,1,0,0,0,121,122,1,0,
        0,0,122,123,1,0,0,0,123,125,3,10,5,0,124,126,5,23,0,0,125,124,1,
        0,0,0,125,126,1,0,0,0,126,9,1,0,0,0,127,130,5,70,0,0,128,130,3,12,
        6,0,129,127,1,0,0,0,129,128,1,0,0,0,130,11,1,0,0,0,131,132,5,51,
        0,0,132,137,3,14,7,0,133,134,5,44,0,0,134,136,3,14,7,0,135,133,1,
        0,0,0,136,139,1,0,0,0,137,135,1,0,0,0,137,138,1,0,0,0,138,140,1,
        0,0,0,139,137,1,0,0,0,140,141,5,52,0,0,141,13,1,0,0,0,142,147,3,
        16,8,0,143,144,5,45,0,0,144,146,3,16,8,0,145,143,1,0,0,0,146,149,
        1,0,0,0,147,145,1,0,0,0,147,148,1,0,0,0,148,15,1,0,0,0,149,147,1,
        0,0,0,150,154,5,55,0,0,151,154,5,70,0,0,152,154,3,8,4,0,153,150,
        1,0,0,0,153,151,1,0,0,0,153,152,1,0,0,0,154,17,1,0,0,0,155,160,7,
        0,0,0,156,157,5,24,0,0,157,159,7,0,0,0,158,156,1,0,0,0,159,162,1,
        0,0,0,160,158,1,0,0,0,160,161,1,0,0,0,161,19,1,0,0,0,162,160,1,0,
        0,0,163,177,3,32,16,0,164,177,3,36,18,0,165,177,3,58,29,0,166,177,
        3,68,34,0,167,177,3,8,4,0,168,177,3,18,9,0,169,177,5,55,0,0,170,
        177,5,56,0,0,171,177,5,70,0,0,172,173,5,53,0,0,173,174,3,20,10,0,
        174,175,5,54,0,0,175,177,1,0,0,0,176,163,1,0,0,0,176,164,1,0,0,0,
        176,165,1,0,0,0,176,166,1,0,0,0,176,167,1,0,0,0,176,168,1,0,0,0,
        176,169,1,0,0,0,176,170,1,0,0,0,176,171,1,0,0,0,176,172,1,0,0,0,
        177,21,1,0,0,0,178,179,7,1,0,0,179,23,1,0,0,0,180,181,5,3,0,0,181,
        182,5,70,0,0,182,184,5,53,0,0,183,185,3,26,13,0,184,183,1,0,0,0,
        184,185,1,0,0,0,185,186,1,0,0,0,186,187,5,54,0,0,187,188,3,56,28,
        0,188,189,5,4,0,0,189,25,1,0,0,0,190,195,3,28,14,0,191,192,5,45,
        0,0,192,194,3,28,14,0,193,191,1,0,0,0,194,197,1,0,0,0,195,193,1,
        0,0,0,195,196,1,0,0,0,196,27,1,0,0,0,197,195,1,0,0,0,198,199,5,70,
        0,0,199,200,3,22,11,0,200,29,1,0,0,0,201,202,5,5,0,0,202,203,3,20,
        10,0,203,31,1,0,0,0,204,206,5,6,0,0,205,204,1,0,0,0,205,206,1,0,
        0,0,206,207,1,0,0,0,207,208,5,70,0,0,208,210,5,53,0,0,209,211,3,
        34,17,0,210,209,1,0,0,0,210,211,1,0,0,0,211,212,1,0,0,0,212,213,
        5,54,0,0,213,33,1,0,0,0,214,219,3,20,10,0,215,216,5,45,0,0,216,218,
        3,20,10,0,217,215,1,0,0,0,218,221,1,0,0,0,219,217,1,0,0,0,219,220,
        1,0,0,0,220,35,1,0,0,0,221,219,1,0,0,0,222,223,5,65,0,0,223,224,
        5,53,0,0,224,225,3,58,29,0,225,226,5,45,0,0,226,227,3,58,29,0,227,
        228,5,54,0,0,228,235,1,0,0,0,229,230,7,2,0,0,230,231,5,53,0,0,231,
        232,3,58,29,0,232,233,5,54,0,0,233,235,1,0,0,0,234,222,1,0,0,0,234,
        229,1,0,0,0,235,37,1,0,0,0,236,237,5,11,0,0,237,238,5,53,0,0,238,
        239,3,68,34,0,239,242,5,54,0,0,240,243,3,2,1,0,241,243,3,56,28,0,
        242,240,1,0,0,0,242,241,1,0,0,0,243,254,1,0,0,0,244,245,5,12,0,0,
        245,246,5,53,0,0,246,247,3,68,34,0,247,250,5,54,0,0,248,251,3,2,
        1,0,249,251,3,56,28,0,250,248,1,0,0,0,250,249,1,0,0,0,251,253,1,
        0,0,0,252,244,1,0,0,0,253,256,1,0,0,0,254,252,1,0,0,0,254,255,1,
        0,0,0,255,262,1,0,0,0,256,254,1,0,0,0,257,260,5,13,0,0,258,261,3,
        2,1,0,259,261,3,56,28,0,260,258,1,0,0,0,260,259,1,0,0,0,261,263,
        1,0,0,0,262,257,1,0,0,0,262,263,1,0,0,0,263,39,1,0,0,0,264,265,5,
        11,0,0,265,266,5,53,0,0,266,267,3,68,34,0,267,277,5,54,0,0,268,270,
        5,51,0,0,269,271,3,4,2,0,270,269,1,0,0,0,271,272,1,0,0,0,272,270,
        1,0,0,0,272,273,1,0,0,0,273,274,1,0,0,0,274,275,5,52,0,0,275,278,
        1,0,0,0,276,278,3,2,1,0,277,268,1,0,0,0,277,276,1,0,0,0,278,296,
        1,0,0,0,279,280,5,12,0,0,280,281,5,53,0,0,281,282,3,68,34,0,282,
        292,5,54,0,0,283,285,5,51,0,0,284,286,3,4,2,0,285,284,1,0,0,0,286,
        287,1,0,0,0,287,285,1,0,0,0,287,288,1,0,0,0,288,289,1,0,0,0,289,
        290,5,52,0,0,290,293,1,0,0,0,291,293,3,2,1,0,292,283,1,0,0,0,292,
        291,1,0,0,0,293,295,1,0,0,0,294,279,1,0,0,0,295,298,1,0,0,0,296,
        294,1,0,0,0,296,297,1,0,0,0,297,311,1,0,0,0,298,296,1,0,0,0,299,
        309,5,13,0,0,300,302,5,51,0,0,301,303,3,4,2,0,302,301,1,0,0,0,303,
        304,1,0,0,0,304,302,1,0,0,0,304,305,1,0,0,0,305,306,1,0,0,0,306,
        307,5,52,0,0,307,310,1,0,0,0,308,310,3,2,1,0,309,300,1,0,0,0,309,
        308,1,0,0,0,310,312,1,0,0,0,311,299,1,0,0,0,311,312,1,0,0,0,312,
        41,1,0,0,0,313,316,3,44,22,0,314,316,3,52,26,0,315,313,1,0,0,0,315,
        314,1,0,0,0,316,43,1,0,0,0,317,318,5,15,0,0,318,320,5,53,0,0,319,
        321,3,46,23,0,320,319,1,0,0,0,320,321,1,0,0,0,321,322,1,0,0,0,322,
        323,5,44,0,0,323,324,3,68,34,0,324,325,5,44,0,0,325,326,3,48,24,
        0,326,327,5,54,0,0,327,328,3,50,25,0,328,45,1,0,0,0,329,332,5,70,
        0,0,330,332,3,6,3,0,331,329,1,0,0,0,331,330,1,0,0,0,332,47,1,0,0,
        0,333,337,3,6,3,0,334,337,3,66,33,0,335,337,3,64,32,0,336,333,1,
        0,0,0,336,334,1,0,0,0,336,335,1,0,0,0,337,49,1,0,0,0,338,340,5,51,
        0,0,339,341,3,4,2,0,340,339,1,0,0,0,341,342,1,0,0,0,342,340,1,0,
        0,0,342,343,1,0,0,0,343,344,1,0,0,0,344,345,5,52,0,0,345,348,1,0,
        0,0,346,348,3,2,1,0,347,338,1,0,0,0,347,346,1,0,0,0,348,51,1,0,0,
        0,349,350,5,20,0,0,350,351,5,53,0,0,351,352,3,68,34,0,352,362,5,
        54,0,0,353,355,5,51,0,0,354,356,3,4,2,0,355,354,1,0,0,0,356,357,
        1,0,0,0,357,355,1,0,0,0,357,358,1,0,0,0,358,359,1,0,0,0,359,360,
        5,52,0,0,360,363,1,0,0,0,361,363,3,2,1,0,362,353,1,0,0,0,362,361,
        1,0,0,0,363,53,1,0,0,0,364,365,5,10,0,0,365,370,3,20,10,0,366,367,
        5,45,0,0,367,369,3,20,10,0,368,366,1,0,0,0,369,372,1,0,0,0,370,368,
        1,0,0,0,370,371,1,0,0,0,371,55,1,0,0,0,372,370,1,0,0,0,373,375,5,
        51,0,0,374,376,3,2,1,0,375,374,1,0,0,0,376,377,1,0,0,0,377,375,1,
        0,0,0,377,378,1,0,0,0,378,379,1,0,0,0,379,380,5,52,0,0,380,57,1,
        0,0,0,381,382,6,29,-1,0,382,383,3,60,30,0,383,389,1,0,0,0,384,385,
        10,2,0,0,385,386,7,3,0,0,386,388,3,60,30,0,387,384,1,0,0,0,388,391,
        1,0,0,0,389,387,1,0,0,0,389,390,1,0,0,0,390,59,1,0,0,0,391,389,1,
        0,0,0,392,393,6,30,-1,0,393,394,3,62,31,0,394,400,1,0,0,0,395,396,
        10,2,0,0,396,397,7,4,0,0,397,399,3,62,31,0,398,395,1,0,0,0,399,402,
        1,0,0,0,400,398,1,0,0,0,400,401,1,0,0,0,401,61,1,0,0,0,402,400,1,
        0,0,0,403,404,5,24,0,0,404,417,3,62,31,0,405,406,5,25,0,0,406,417,
        3,62,31,0,407,417,3,32,16,0,408,417,5,55,0,0,409,417,5,70,0,0,410,
        417,5,56,0,0,411,417,3,64,32,0,412,413,5,53,0,0,413,414,3,58,29,
        0,414,415,5,54,0,0,415,417,1,0,0,0,416,403,1,0,0,0,416,405,1,0,0,
        0,416,407,1,0,0,0,416,408,1,0,0,0,416,409,1,0,0,0,416,410,1,0,0,
        0,416,411,1,0,0,0,416,412,1,0,0,0,417,63,1,0,0,0,418,419,5,70,0,
        0,419,422,7,5,0,0,420,422,3,32,16,0,421,418,1,0,0,0,421,420,1,0,
        0,0,422,65,1,0,0,0,423,436,5,70,0,0,424,425,5,34,0,0,425,429,5,56,
        0,0,426,427,5,34,0,0,427,429,3,58,29,0,428,424,1,0,0,0,428,426,1,
        0,0,0,429,437,1,0,0,0,430,431,5,35,0,0,431,437,3,58,29,0,432,433,
        5,39,0,0,433,437,3,58,29,0,434,435,5,38,0,0,435,437,3,58,29,0,436,
        428,1,0,0,0,436,430,1,0,0,0,436,432,1,0,0,0,436,434,1,0,0,0,437,
        438,1,0,0,0,438,439,5,44,0,0,439,67,1,0,0,0,440,441,3,70,35,0,441,
        69,1,0,0,0,442,447,3,72,36,0,443,444,5,42,0,0,444,446,3,72,36,0,
        445,443,1,0,0,0,446,449,1,0,0,0,447,445,1,0,0,0,447,448,1,0,0,0,
        448,71,1,0,0,0,449,447,1,0,0,0,450,455,3,74,37,0,451,452,5,41,0,
        0,452,454,3,74,37,0,453,451,1,0,0,0,454,457,1,0,0,0,455,453,1,0,
        0,0,455,456,1,0,0,0,456,73,1,0,0,0,457,455,1,0,0,0,458,459,5,43,
        0,0,459,462,3,74,37,0,460,462,3,76,38,0,461,458,1,0,0,0,461,460,
        1,0,0,0,462,75,1,0,0,0,463,464,3,58,29,0,464,465,3,78,39,0,465,466,
        3,58,29,0,466,483,1,0,0,0,467,468,3,18,9,0,468,469,7,6,0,0,469,470,
        3,18,9,0,470,483,1,0,0,0,471,472,3,8,4,0,472,473,7,6,0,0,473,474,
        3,8,4,0,474,483,1,0,0,0,475,476,5,53,0,0,476,477,3,68,34,0,477,478,
        5,54,0,0,478,483,1,0,0,0,479,483,5,63,0,0,480,483,5,64,0,0,481,483,
        5,70,0,0,482,463,1,0,0,0,482,467,1,0,0,0,482,471,1,0,0,0,482,475,
        1,0,0,0,482,479,1,0,0,0,482,480,1,0,0,0,482,481,1,0,0,0,483,77,1,
        0,0,0,484,485,7,7,0,0,485,79,1,0,0,0,51,84,99,110,113,121,125,129,
        137,147,153,160,176,184,195,205,210,219,234,242,250,254,260,262,
        272,277,287,292,296,304,309,311,315,320,331,336,342,347,357,362,
        370,377,389,400,416,421,428,436,447,455,461,482
    ]

class EnglishLangParser ( Parser ):

    grammarFileName = "EnglishLangParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'Start Program'", "'End Program'", "'Define Function'", 
                     "'End Function'", "'Return'", "'Call'", "'with'", "'Set'", 
                     "'to'", "'Display'", "'If'", "'Else If'", "'Else'", 
                     "'End If'", "'For'", "'from'", "'in'", "'End For'", 
                     "'break'", "'While'", "'End While'", "'invert'", "''T'", 
                     "'+'", "'-'", "'*'", "'/'", "'%'", "'=='", "'>'", "'<'", 
                     "'>='", "'<='", "'+='", "'-='", "'++'", "'--'", "'*='", 
                     "'/='", "'!='", "'and'", "'or'", "'not'", "';'", "','", 
                     "':'", "'.'", "'\"'", "'['", "']'", "'{'", "'}'", "'('", 
                     "')'", "<INVALID>", "<INVALID>", "'int'", "'string'", 
                     "'bool'", "'float'", "'matrix'", "'void'", "'true'", 
                     "'false'", "'pow'", "'sin'", "'cos'", "'tan'", "'ctan'" ]

    symbolicNames = [ "<INVALID>", "START_PROGRAM", "END_PROGRAM", "DEFINE_FUNCTION", 
                      "END_FUNCTION", "RETURN", "CALL", "WITH", "SET", "TO", 
                      "DISPLAY", "IF", "ELSE_IF", "ELSE", "END_IF", "FOR", 
                      "FROM", "IN", "END_FOR", "BREAK", "WHILE", "END_WHILE", 
                      "INVERT_MATRIX", "TRANSPOSITION", "PLUS", "MINUS", 
                      "MULTIPLY", "DIVIDED_BY", "MODULO", "EQUALS", "GREATER_THAN", 
                      "LESS_THAN", "GREATER_EQUAL", "LESS_EQUAL", "ADD_TO", 
                      "SUBTRACT_FROM", "INCREMENT", "DECREMENT", "TIMES", 
                      "DIVIDE_FROM", "NOT_EQUALS", "AND", "OR", "NOT", "SEMICOLON", 
                      "COMMA", "COLON", "DOT", "QUOTE", "LBRACK", "RBRACK", 
                      "LBRACE", "RBRACE", "LPAREN", "RPAREN", "NUMBER", 
                      "STRING", "TYPE_INT", "TYPE_STRING", "TYPE_BOOL", 
                      "TYPE_FLOAT", "TYPE_MATRIX", "TYPE_VOID", "TRUE_VALUE", 
                      "FALSE_VALUE", "POWER_FUNC", "SIN_FUNC", "COS_FUNC", 
                      "TAN_FUNC", "CTAN_FUNC", "IDENTIFIER", "WS", "COMMENT" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_loopStatements = 2
    RULE_variableDeclaration = 3
    RULE_matrixExpression = 4
    RULE_matrixAtom = 5
    RULE_matrixConstruction = 6
    RULE_row = 7
    RULE_value = 8
    RULE_stringExpression = 9
    RULE_expression = 10
    RULE_typeAnnotation = 11
    RULE_functionDeclaration = 12
    RULE_parameter = 13
    RULE_typedParameter = 14
    RULE_returnStatement = 15
    RULE_functionCall = 16
    RULE_argumentList = 17
    RULE_builtInFunctions = 18
    RULE_ifStatement = 19
    RULE_loopIfStatement = 20
    RULE_loopStatement = 21
    RULE_forLoop = 22
    RULE_forInit = 23
    RULE_forUpdate = 24
    RULE_forBody = 25
    RULE_whileLoop = 26
    RULE_displayStatement = 27
    RULE_block = 28
    RULE_numExpression = 29
    RULE_term = 30
    RULE_factor = 31
    RULE_operation = 32
    RULE_reassignment = 33
    RULE_boolExpression = 34
    RULE_boolOrExpression = 35
    RULE_boolAndExpression = 36
    RULE_boolNotExpression = 37
    RULE_boolPrimary = 38
    RULE_comparisonOp = 39

    ruleNames =  [ "program", "statement", "loopStatements", "variableDeclaration", 
                   "matrixExpression", "matrixAtom", "matrixConstruction", 
                   "row", "value", "stringExpression", "expression", "typeAnnotation", 
                   "functionDeclaration", "parameter", "typedParameter", 
                   "returnStatement", "functionCall", "argumentList", "builtInFunctions", 
                   "ifStatement", "loopIfStatement", "loopStatement", "forLoop", 
                   "forInit", "forUpdate", "forBody", "whileLoop", "displayStatement", 
                   "block", "numExpression", "term", "factor", "operation", 
                   "reassignment", "boolExpression", "boolOrExpression", 
                   "boolAndExpression", "boolNotExpression", "boolPrimary", 
                   "comparisonOp" ]

    EOF = Token.EOF
    START_PROGRAM=1
    END_PROGRAM=2
    DEFINE_FUNCTION=3
    END_FUNCTION=4
    RETURN=5
    CALL=6
    WITH=7
    SET=8
    TO=9
    DISPLAY=10
    IF=11
    ELSE_IF=12
    ELSE=13
    END_IF=14
    FOR=15
    FROM=16
    IN=17
    END_FOR=18
    BREAK=19
    WHILE=20
    END_WHILE=21
    INVERT_MATRIX=22
    TRANSPOSITION=23
    PLUS=24
    MINUS=25
    MULTIPLY=26
    DIVIDED_BY=27
    MODULO=28
    EQUALS=29
    GREATER_THAN=30
    LESS_THAN=31
    GREATER_EQUAL=32
    LESS_EQUAL=33
    ADD_TO=34
    SUBTRACT_FROM=35
    INCREMENT=36
    DECREMENT=37
    TIMES=38
    DIVIDE_FROM=39
    NOT_EQUALS=40
    AND=41
    OR=42
    NOT=43
    SEMICOLON=44
    COMMA=45
    COLON=46
    DOT=47
    QUOTE=48
    LBRACK=49
    RBRACK=50
    LBRACE=51
    RBRACE=52
    LPAREN=53
    RPAREN=54
    NUMBER=55
    STRING=56
    TYPE_INT=57
    TYPE_STRING=58
    TYPE_BOOL=59
    TYPE_FLOAT=60
    TYPE_MATRIX=61
    TYPE_VOID=62
    TRUE_VALUE=63
    FALSE_VALUE=64
    POWER_FUNC=65
    SIN_FUNC=66
    COS_FUNC=67
    TAN_FUNC=68
    CTAN_FUNC=69
    IDENTIFIER=70
    WS=71
    COMMENT=72

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def START_PROGRAM(self):
            return self.getToken(EnglishLangParser.START_PROGRAM, 0)

        def END_PROGRAM(self):
            return self.getToken(EnglishLangParser.END_PROGRAM, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = EnglishLangParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self.match(EnglishLangParser.START_PROGRAM)
            self.state = 82 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 81
                self.statement()
                self.state = 84 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1084776) != 0) or _la==70):
                    break

            self.state = 86
            self.match(EnglishLangParser.END_PROGRAM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(EnglishLangParser.ReassignmentContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionDeclarationContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionCallContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.ReturnStatementContext,0)


        def displayStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.DisplayStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.IfStatementContext,0)


        def loopStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.LoopStatementContext,0)


        def forLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.ForLoopContext,0)


        def whileLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.WhileLoopContext,0)


        def operation(self):
            return self.getTypedRuleContext(EnglishLangParser.OperationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = EnglishLangParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 99
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 88
                self.variableDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 89
                self.reassignment()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 90
                self.functionDeclaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 91
                self.functionCall()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 92
                self.returnStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 93
                self.displayStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 94
                self.ifStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 95
                self.loopStatement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 96
                self.forLoop()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 97
                self.whileLoop()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 98
                self.operation()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopStatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.LoopStatementContext,0)


        def variableDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(EnglishLangParser.ReassignmentContext,0)


        def functionDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionDeclarationContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.ReturnStatementContext,0)


        def loopIfStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.LoopIfStatementContext,0)


        def block(self):
            return self.getTypedRuleContext(EnglishLangParser.BlockContext,0)


        def BREAK(self):
            return self.getToken(EnglishLangParser.BREAK, 0)

        def displayStatement(self):
            return self.getTypedRuleContext(EnglishLangParser.DisplayStatementContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_loopStatements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopStatements" ):
                listener.enterLoopStatements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopStatements" ):
                listener.exitLoopStatements(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopStatements" ):
                return visitor.visitLoopStatements(self)
            else:
                return visitor.visitChildren(self)




    def loopStatements(self):

        localctx = EnglishLangParser.LoopStatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_loopStatements)
        try:
            self.state = 110
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 101
                self.loopStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 102
                self.variableDeclaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 103
                self.reassignment()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 104
                self.functionDeclaration()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 105
                self.returnStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 106
                self.loopIfStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 107
                self.block()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 108
                self.match(EnglishLangParser.BREAK)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 109
                self.displayStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def TO(self):
            return self.getToken(EnglishLangParser.TO, 0)

        def expression(self):
            return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,0)


        def typeAnnotation(self):
            return self.getTypedRuleContext(EnglishLangParser.TypeAnnotationContext,0)


        def SET(self):
            return self.getToken(EnglishLangParser.SET, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_variableDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableDeclaration" ):
                listener.enterVariableDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableDeclaration" ):
                listener.exitVariableDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableDeclaration" ):
                return visitor.visitVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def variableDeclaration(self):

        localctx = EnglishLangParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_variableDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 112
                self.match(EnglishLangParser.SET)


            self.state = 115
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 116
            self.match(EnglishLangParser.TO)
            self.state = 117
            self.expression()
            self.state = 118
            self.typeAnnotation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def matrixAtom(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixAtomContext,0)


        def INVERT_MATRIX(self):
            return self.getToken(EnglishLangParser.INVERT_MATRIX, 0)

        def TRANSPOSITION(self):
            return self.getToken(EnglishLangParser.TRANSPOSITION, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_matrixExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixExpression" ):
                listener.enterMatrixExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixExpression" ):
                listener.exitMatrixExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixExpression" ):
                return visitor.visitMatrixExpression(self)
            else:
                return visitor.visitChildren(self)




    def matrixExpression(self):

        localctx = EnglishLangParser.MatrixExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_matrixExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 120
                self.match(EnglishLangParser.INVERT_MATRIX)


            self.state = 123
            self.matrixAtom()
            self.state = 125
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==23:
                self.state = 124
                self.match(EnglishLangParser.TRANSPOSITION)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixAtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def matrixConstruction(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixConstructionContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_matrixAtom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixAtom" ):
                listener.enterMatrixAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixAtom" ):
                listener.exitMatrixAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixAtom" ):
                return visitor.visitMatrixAtom(self)
            else:
                return visitor.visitChildren(self)




    def matrixAtom(self):

        localctx = EnglishLangParser.MatrixAtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_matrixAtom)
        try:
            self.state = 129
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [70]:
                self.enterOuterAlt(localctx, 1)
                self.state = 127
                self.match(EnglishLangParser.IDENTIFIER)
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 2)
                self.state = 128
                self.matrixConstruction()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatrixConstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def row(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.RowContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.RowContext,i)


        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.SEMICOLON)
            else:
                return self.getToken(EnglishLangParser.SEMICOLON, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_matrixConstruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixConstruction" ):
                listener.enterMatrixConstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixConstruction" ):
                listener.exitMatrixConstruction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixConstruction" ):
                return visitor.visitMatrixConstruction(self)
            else:
                return visitor.visitChildren(self)




    def matrixConstruction(self):

        localctx = EnglishLangParser.MatrixConstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_matrixConstruction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self.match(EnglishLangParser.LBRACE)
            self.state = 132
            self.row()
            self.state = 137
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==44:
                self.state = 133
                self.match(EnglishLangParser.SEMICOLON)
                self.state = 134
                self.row()
                self.state = 139
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 140
            self.match(EnglishLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.ValueContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.ValueContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_row

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRow" ):
                listener.enterRow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRow" ):
                listener.exitRow(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRow" ):
                return visitor.visitRow(self)
            else:
                return visitor.visitChildren(self)




    def row(self):

        localctx = EnglishLangParser.RowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_row)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.value()
            self.state = 147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==45:
                self.state = 143
                self.match(EnglishLangParser.COMMA)
                self.state = 144
                self.value()
                self.state = 149
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(EnglishLangParser.NUMBER, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def matrixExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixExpressionContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue" ):
                listener.enterValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue" ):
                listener.exitValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValue" ):
                return visitor.visitValue(self)
            else:
                return visitor.visitChildren(self)




    def value(self):

        localctx = EnglishLangParser.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_value)
        try:
            self.state = 153
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 150
                self.match(EnglishLangParser.NUMBER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 151
                self.match(EnglishLangParser.IDENTIFIER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 152
                self.matrixExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.STRING)
            else:
                return self.getToken(EnglishLangParser.STRING, i)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.IDENTIFIER)
            else:
                return self.getToken(EnglishLangParser.IDENTIFIER, i)

        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.PLUS)
            else:
                return self.getToken(EnglishLangParser.PLUS, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_stringExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringExpression" ):
                listener.enterStringExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringExpression" ):
                listener.exitStringExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringExpression" ):
                return visitor.visitStringExpression(self)
            else:
                return visitor.visitChildren(self)




    def stringExpression(self):

        localctx = EnglishLangParser.StringExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_stringExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 155
            _la = self._input.LA(1)
            if not(_la==56 or _la==70):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 160
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==24:
                self.state = 156
                self.match(EnglishLangParser.PLUS)
                self.state = 157
                _la = self._input.LA(1)
                if not(_la==56 or _la==70):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 162
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionCall(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionCallContext,0)


        def builtInFunctions(self):
            return self.getTypedRuleContext(EnglishLangParser.BuiltInFunctionsContext,0)


        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)


        def matrixExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.MatrixExpressionContext,0)


        def stringExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.StringExpressionContext,0)


        def NUMBER(self):
            return self.getToken(EnglishLangParser.NUMBER, 0)

        def STRING(self):
            return self.getToken(EnglishLangParser.STRING, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,0)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = EnglishLangParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_expression)
        try:
            self.state = 176
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 163
                self.functionCall()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 164
                self.builtInFunctions()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 165
                self.numExpression(0)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 166
                self.boolExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 167
                self.matrixExpression()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 168
                self.stringExpression()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 169
                self.match(EnglishLangParser.NUMBER)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 170
                self.match(EnglishLangParser.STRING)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 171
                self.match(EnglishLangParser.IDENTIFIER)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 172
                self.match(EnglishLangParser.LPAREN)
                self.state = 173
                self.expression()
                self.state = 174
                self.match(EnglishLangParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeAnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE_STRING(self):
            return self.getToken(EnglishLangParser.TYPE_STRING, 0)

        def TYPE_INT(self):
            return self.getToken(EnglishLangParser.TYPE_INT, 0)

        def TYPE_FLOAT(self):
            return self.getToken(EnglishLangParser.TYPE_FLOAT, 0)

        def TYPE_BOOL(self):
            return self.getToken(EnglishLangParser.TYPE_BOOL, 0)

        def TYPE_MATRIX(self):
            return self.getToken(EnglishLangParser.TYPE_MATRIX, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_typeAnnotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeAnnotation" ):
                listener.enterTypeAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeAnnotation" ):
                listener.exitTypeAnnotation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeAnnotation" ):
                return visitor.visitTypeAnnotation(self)
            else:
                return visitor.visitChildren(self)




    def typeAnnotation(self):

        localctx = EnglishLangParser.TypeAnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_typeAnnotation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 4467570830351532032) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE_FUNCTION(self):
            return self.getToken(EnglishLangParser.DEFINE_FUNCTION, 0)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def block(self):
            return self.getTypedRuleContext(EnglishLangParser.BlockContext,0)


        def END_FUNCTION(self):
            return self.getToken(EnglishLangParser.END_FUNCTION, 0)

        def parameter(self):
            return self.getTypedRuleContext(EnglishLangParser.ParameterContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_functionDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDeclaration" ):
                listener.enterFunctionDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDeclaration" ):
                listener.exitFunctionDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDeclaration" ):
                return visitor.visitFunctionDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def functionDeclaration(self):

        localctx = EnglishLangParser.FunctionDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_functionDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            self.match(EnglishLangParser.DEFINE_FUNCTION)
            self.state = 181
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 182
            self.match(EnglishLangParser.LPAREN)
            self.state = 184
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==70:
                self.state = 183
                self.parameter()


            self.state = 186
            self.match(EnglishLangParser.RPAREN)
            self.state = 187
            self.block()
            self.state = 188
            self.match(EnglishLangParser.END_FUNCTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typedParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.TypedParameterContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.TypedParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = EnglishLangParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_parameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self.typedParameter()
            self.state = 195
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==45:
                self.state = 191
                self.match(EnglishLangParser.COMMA)
                self.state = 192
                self.typedParameter()
                self.state = 197
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypedParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def typeAnnotation(self):
            return self.getTypedRuleContext(EnglishLangParser.TypeAnnotationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_typedParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypedParameter" ):
                listener.enterTypedParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypedParameter" ):
                listener.exitTypedParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypedParameter" ):
                return visitor.visitTypedParameter(self)
            else:
                return visitor.visitChildren(self)




    def typedParameter(self):

        localctx = EnglishLangParser.TypedParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_typedParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 199
            self.typeAnnotation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(EnglishLangParser.RETURN, 0)

        def expression(self):
            return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_returnStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnStatement" ):
                listener.enterReturnStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnStatement" ):
                listener.exitReturnStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStatement" ):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)




    def returnStatement(self):

        localctx = EnglishLangParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.match(EnglishLangParser.RETURN)
            self.state = 202
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def CALL(self):
            return self.getToken(EnglishLangParser.CALL, 0)

        def argumentList(self):
            return self.getTypedRuleContext(EnglishLangParser.ArgumentListContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = EnglishLangParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_functionCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 204
                self.match(EnglishLangParser.CALL)


            self.state = 207
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 208
            self.match(EnglishLangParser.LPAREN)
            self.state = 210
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & -9104017850581909440) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 127) != 0):
                self.state = 209
                self.argumentList()


            self.state = 212
            self.match(EnglishLangParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_argumentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgumentList" ):
                listener.enterArgumentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgumentList" ):
                listener.exitArgumentList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgumentList" ):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)




    def argumentList(self):

        localctx = EnglishLangParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_argumentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            self.expression()
            self.state = 219
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==45:
                self.state = 215
                self.match(EnglishLangParser.COMMA)
                self.state = 216
                self.expression()
                self.state = 221
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BuiltInFunctionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POWER_FUNC(self):
            return self.getToken(EnglishLangParser.POWER_FUNC, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def numExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.NumExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,i)


        def COMMA(self):
            return self.getToken(EnglishLangParser.COMMA, 0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def SIN_FUNC(self):
            return self.getToken(EnglishLangParser.SIN_FUNC, 0)

        def COS_FUNC(self):
            return self.getToken(EnglishLangParser.COS_FUNC, 0)

        def TAN_FUNC(self):
            return self.getToken(EnglishLangParser.TAN_FUNC, 0)

        def CTAN_FUNC(self):
            return self.getToken(EnglishLangParser.CTAN_FUNC, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_builtInFunctions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBuiltInFunctions" ):
                listener.enterBuiltInFunctions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBuiltInFunctions" ):
                listener.exitBuiltInFunctions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBuiltInFunctions" ):
                return visitor.visitBuiltInFunctions(self)
            else:
                return visitor.visitChildren(self)




    def builtInFunctions(self):

        localctx = EnglishLangParser.BuiltInFunctionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_builtInFunctions)
        self._la = 0 # Token type
        try:
            self.state = 234
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [65]:
                self.enterOuterAlt(localctx, 1)
                self.state = 222
                self.match(EnglishLangParser.POWER_FUNC)
                self.state = 223
                self.match(EnglishLangParser.LPAREN)
                self.state = 224
                self.numExpression(0)
                self.state = 225
                self.match(EnglishLangParser.COMMA)
                self.state = 226
                self.numExpression(0)
                self.state = 227
                self.match(EnglishLangParser.RPAREN)
                pass
            elif token in [66, 67, 68, 69]:
                self.enterOuterAlt(localctx, 2)
                self.state = 229
                _la = self._input.LA(1)
                if not(((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 15) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 230
                self.match(EnglishLangParser.LPAREN)
                self.state = 231
                self.numExpression(0)
                self.state = 232
                self.match(EnglishLangParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(EnglishLangParser.IF, 0)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.LPAREN)
            else:
                return self.getToken(EnglishLangParser.LPAREN, i)

        def boolExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,i)


        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.RPAREN)
            else:
                return self.getToken(EnglishLangParser.RPAREN, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def block(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BlockContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BlockContext,i)


        def ELSE_IF(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.ELSE_IF)
            else:
                return self.getToken(EnglishLangParser.ELSE_IF, i)

        def ELSE(self):
            return self.getToken(EnglishLangParser.ELSE, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStatement(self):

        localctx = EnglishLangParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_ifStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            self.match(EnglishLangParser.IF)
            self.state = 237
            self.match(EnglishLangParser.LPAREN)
            self.state = 238
            self.boolExpression()
            self.state = 239
            self.match(EnglishLangParser.RPAREN)
            self.state = 242
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                self.state = 240
                self.statement()
                pass
            elif token in [51]:
                self.state = 241
                self.block()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 254
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,20,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 244
                    self.match(EnglishLangParser.ELSE_IF)
                    self.state = 245
                    self.match(EnglishLangParser.LPAREN)
                    self.state = 246
                    self.boolExpression()
                    self.state = 247
                    self.match(EnglishLangParser.RPAREN)
                    self.state = 250
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                        self.state = 248
                        self.statement()
                        pass
                    elif token in [51]:
                        self.state = 249
                        self.block()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 256
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

            self.state = 262
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.state = 257
                self.match(EnglishLangParser.ELSE)
                self.state = 260
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                    self.state = 258
                    self.statement()
                    pass
                elif token in [51]:
                    self.state = 259
                    self.block()
                    pass
                else:
                    raise NoViableAltException(self)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopIfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(EnglishLangParser.IF, 0)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.LPAREN)
            else:
                return self.getToken(EnglishLangParser.LPAREN, i)

        def boolExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,i)


        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.RPAREN)
            else:
                return self.getToken(EnglishLangParser.RPAREN, i)

        def LBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.LBRACE)
            else:
                return self.getToken(EnglishLangParser.LBRACE, i)

        def RBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.RBRACE)
            else:
                return self.getToken(EnglishLangParser.RBRACE, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def ELSE_IF(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.ELSE_IF)
            else:
                return self.getToken(EnglishLangParser.ELSE_IF, i)

        def ELSE(self):
            return self.getToken(EnglishLangParser.ELSE, 0)

        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.LoopStatementsContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_loopIfStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopIfStatement" ):
                listener.enterLoopIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopIfStatement" ):
                listener.exitLoopIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopIfStatement" ):
                return visitor.visitLoopIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def loopIfStatement(self):

        localctx = EnglishLangParser.LoopIfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_loopIfStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(EnglishLangParser.IF)
            self.state = 265
            self.match(EnglishLangParser.LPAREN)
            self.state = 266
            self.boolExpression()
            self.state = 267
            self.match(EnglishLangParser.RPAREN)
            self.state = 277
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51]:
                self.state = 268
                self.match(EnglishLangParser.LBRACE)
                self.state = 270 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 269
                    self.loopStatements()
                    self.state = 272 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815294248) != 0) or _la==70):
                        break

                self.state = 274
                self.match(EnglishLangParser.RBRACE)
                pass
            elif token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                self.state = 276
                self.statement()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 296
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==12:
                self.state = 279
                self.match(EnglishLangParser.ELSE_IF)
                self.state = 280
                self.match(EnglishLangParser.LPAREN)
                self.state = 281
                self.boolExpression()
                self.state = 282
                self.match(EnglishLangParser.RPAREN)
                self.state = 292
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [51]:
                    self.state = 283
                    self.match(EnglishLangParser.LBRACE)
                    self.state = 285 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 284
                        self.loopStatements()
                        self.state = 287 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815294248) != 0) or _la==70):
                            break

                    self.state = 289
                    self.match(EnglishLangParser.RBRACE)
                    pass
                elif token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                    self.state = 291
                    self.statement()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 298
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 311
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==13:
                self.state = 299
                self.match(EnglishLangParser.ELSE)
                self.state = 309
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [51]:
                    self.state = 300
                    self.match(EnglishLangParser.LBRACE)
                    self.state = 302 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 301
                        self.loopStatements()
                        self.state = 304 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815294248) != 0) or _la==70):
                            break

                    self.state = 306
                    self.match(EnglishLangParser.RBRACE)
                    pass
                elif token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                    self.state = 308
                    self.statement()
                    pass
                else:
                    raise NoViableAltException(self)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.ForLoopContext,0)


        def whileLoop(self):
            return self.getTypedRuleContext(EnglishLangParser.WhileLoopContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_loopStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopStatement" ):
                listener.enterLoopStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopStatement" ):
                listener.exitLoopStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopStatement" ):
                return visitor.visitLoopStatement(self)
            else:
                return visitor.visitChildren(self)




    def loopStatement(self):

        localctx = EnglishLangParser.LoopStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_loopStatement)
        try:
            self.state = 315
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [15]:
                self.enterOuterAlt(localctx, 1)
                self.state = 313
                self.forLoop()
                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 2)
                self.state = 314
                self.whileLoop()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForLoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.cond = None # BoolExpressionContext

        def FOR(self):
            return self.getToken(EnglishLangParser.FOR, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.SEMICOLON)
            else:
                return self.getToken(EnglishLangParser.SEMICOLON, i)

        def forUpdate(self):
            return self.getTypedRuleContext(EnglishLangParser.ForUpdateContext,0)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def forBody(self):
            return self.getTypedRuleContext(EnglishLangParser.ForBodyContext,0)


        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)


        def forInit(self):
            return self.getTypedRuleContext(EnglishLangParser.ForInitContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_forLoop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForLoop" ):
                listener.enterForLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForLoop" ):
                listener.exitForLoop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForLoop" ):
                return visitor.visitForLoop(self)
            else:
                return visitor.visitChildren(self)




    def forLoop(self):

        localctx = EnglishLangParser.ForLoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_forLoop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 317
            self.match(EnglishLangParser.FOR)
            self.state = 318
            self.match(EnglishLangParser.LPAREN)
            self.state = 320
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8 or _la==70:
                self.state = 319
                self.forInit()


            self.state = 322
            self.match(EnglishLangParser.SEMICOLON)
            self.state = 323
            localctx.cond = self.boolExpression()
            self.state = 324
            self.match(EnglishLangParser.SEMICOLON)
            self.state = 325
            self.forUpdate()
            self.state = 326
            self.match(EnglishLangParser.RPAREN)
            self.state = 327
            self.forBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForInitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def variableDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_forInit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForInit" ):
                listener.enterForInit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForInit" ):
                listener.exitForInit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForInit" ):
                return visitor.visitForInit(self)
            else:
                return visitor.visitChildren(self)




    def forInit(self):

        localctx = EnglishLangParser.ForInitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_forInit)
        try:
            self.state = 331
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 329
                self.match(EnglishLangParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 330
                self.variableDeclaration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForUpdateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclaration(self):
            return self.getTypedRuleContext(EnglishLangParser.VariableDeclarationContext,0)


        def reassignment(self):
            return self.getTypedRuleContext(EnglishLangParser.ReassignmentContext,0)


        def operation(self):
            return self.getTypedRuleContext(EnglishLangParser.OperationContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_forUpdate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForUpdate" ):
                listener.enterForUpdate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForUpdate" ):
                listener.exitForUpdate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForUpdate" ):
                return visitor.visitForUpdate(self)
            else:
                return visitor.visitChildren(self)




    def forUpdate(self):

        localctx = EnglishLangParser.ForUpdateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_forUpdate)
        try:
            self.state = 336
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 333
                self.variableDeclaration()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 334
                self.reassignment()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 335
                self.operation()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.LoopStatementsContext,i)


        def statement(self):
            return self.getTypedRuleContext(EnglishLangParser.StatementContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_forBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForBody" ):
                listener.enterForBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForBody" ):
                listener.exitForBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForBody" ):
                return visitor.visitForBody(self)
            else:
                return visitor.visitChildren(self)




    def forBody(self):

        localctx = EnglishLangParser.ForBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_forBody)
        self._la = 0 # Token type
        try:
            self.state = 347
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51]:
                self.enterOuterAlt(localctx, 1)
                self.state = 338
                self.match(EnglishLangParser.LBRACE)
                self.state = 340 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 339
                    self.loopStatements()
                    self.state = 342 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815294248) != 0) or _la==70):
                        break

                self.state = 344
                self.match(EnglishLangParser.RBRACE)
                pass
            elif token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                self.enterOuterAlt(localctx, 2)
                self.state = 346
                self.statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileLoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(EnglishLangParser.WHILE, 0)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)

        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)


        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def statement(self):
            return self.getTypedRuleContext(EnglishLangParser.StatementContext,0)


        def loopStatements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.LoopStatementsContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.LoopStatementsContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_whileLoop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileLoop" ):
                listener.enterWhileLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileLoop" ):
                listener.exitWhileLoop(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhileLoop" ):
                return visitor.visitWhileLoop(self)
            else:
                return visitor.visitChildren(self)




    def whileLoop(self):

        localctx = EnglishLangParser.WhileLoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_whileLoop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 349
            self.match(EnglishLangParser.WHILE)
            self.state = 350
            self.match(EnglishLangParser.LPAREN)
            self.state = 351
            self.boolExpression()
            self.state = 352
            self.match(EnglishLangParser.RPAREN)
            self.state = 362
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51]:
                self.state = 353
                self.match(EnglishLangParser.LBRACE)
                self.state = 355 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 354
                    self.loopStatements()
                    self.state = 357 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 2251799815294248) != 0) or _la==70):
                        break

                self.state = 359
                self.match(EnglishLangParser.RBRACE)
                pass
            elif token in [3, 5, 6, 8, 10, 11, 15, 20, 70]:
                self.state = 361
                self.statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DisplayStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISPLAY(self):
            return self.getToken(EnglishLangParser.DISPLAY, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.COMMA)
            else:
                return self.getToken(EnglishLangParser.COMMA, i)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_displayStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDisplayStatement" ):
                listener.enterDisplayStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDisplayStatement" ):
                listener.exitDisplayStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDisplayStatement" ):
                return visitor.visitDisplayStatement(self)
            else:
                return visitor.visitChildren(self)




    def displayStatement(self):

        localctx = EnglishLangParser.DisplayStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_displayStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 364
            self.match(EnglishLangParser.DISPLAY)
            self.state = 365
            self.expression()
            self.state = 370
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==45:
                self.state = 366
                self.match(EnglishLangParser.COMMA)
                self.state = 367
                self.expression()
                self.state = 372
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(EnglishLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(EnglishLangParser.RBRACE, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StatementContext,i)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBlock" ):
                listener.enterBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBlock" ):
                listener.exitBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock" ):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)




    def block(self):

        localctx = EnglishLangParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 373
            self.match(EnglishLangParser.LBRACE)
            self.state = 375 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 374
                self.statement()
                self.state = 377 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1084776) != 0) or _la==70):
                    break

            self.state = 379
            self.match(EnglishLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self):
            return self.getTypedRuleContext(EnglishLangParser.TermContext,0)


        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def PLUS(self):
            return self.getToken(EnglishLangParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(EnglishLangParser.MINUS, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_numExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumExpression" ):
                listener.enterNumExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumExpression" ):
                listener.exitNumExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumExpression" ):
                return visitor.visitNumExpression(self)
            else:
                return visitor.visitChildren(self)



    def numExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = EnglishLangParser.NumExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 58
        self.enterRecursionRule(localctx, 58, self.RULE_numExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 382
            self.term(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 389
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,41,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = EnglishLangParser.NumExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_numExpression)
                    self.state = 384
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 385
                    _la = self._input.LA(1)
                    if not(_la==24 or _la==25):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 386
                    self.term(0) 
                self.state = 391
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,41,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self):
            return self.getTypedRuleContext(EnglishLangParser.FactorContext,0)


        def term(self):
            return self.getTypedRuleContext(EnglishLangParser.TermContext,0)


        def MULTIPLY(self):
            return self.getToken(EnglishLangParser.MULTIPLY, 0)

        def DIVIDED_BY(self):
            return self.getToken(EnglishLangParser.DIVIDED_BY, 0)

        def MODULO(self):
            return self.getToken(EnglishLangParser.MODULO, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm" ):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)



    def term(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = EnglishLangParser.TermContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 60
        self.enterRecursionRule(localctx, 60, self.RULE_term, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 393
            self.factor()
            self._ctx.stop = self._input.LT(-1)
            self.state = 400
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,42,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = EnglishLangParser.TermContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_term)
                    self.state = 395
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 396
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 469762048) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 397
                    self.factor() 
                self.state = 402
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,42,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class FactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return EnglishLangParser.RULE_factor

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class FactorOperationContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def operation(self):
            return self.getTypedRuleContext(EnglishLangParser.OperationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorOperation" ):
                listener.enterFactorOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorOperation" ):
                listener.exitFactorOperation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorOperation" ):
                return visitor.visitFactorOperation(self)
            else:
                return visitor.visitChildren(self)


    class UnaryPlusContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def PLUS(self):
            return self.getToken(EnglishLangParser.PLUS, 0)
        def factor(self):
            return self.getTypedRuleContext(EnglishLangParser.FactorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryPlus" ):
                listener.enterUnaryPlus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryPlus" ):
                listener.exitUnaryPlus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryPlus" ):
                return visitor.visitUnaryPlus(self)
            else:
                return visitor.visitChildren(self)


    class FactorIdentifierContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorIdentifier" ):
                listener.enterFactorIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorIdentifier" ):
                listener.exitFactorIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorIdentifier" ):
                return visitor.visitFactorIdentifier(self)
            else:
                return visitor.visitChildren(self)


    class FactorFunctionCallContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def functionCall(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionCallContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorFunctionCall" ):
                listener.enterFactorFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorFunctionCall" ):
                listener.exitFactorFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorFunctionCall" ):
                return visitor.visitFactorFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class FactorNumberContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(EnglishLangParser.NUMBER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorNumber" ):
                listener.enterFactorNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorNumber" ):
                listener.exitFactorNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorNumber" ):
                return visitor.visitFactorNumber(self)
            else:
                return visitor.visitChildren(self)


    class UnaryMinusContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MINUS(self):
            return self.getToken(EnglishLangParser.MINUS, 0)
        def factor(self):
            return self.getTypedRuleContext(EnglishLangParser.FactorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMinus" ):
                listener.enterUnaryMinus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMinus" ):
                listener.exitUnaryMinus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMinus" ):
                return visitor.visitUnaryMinus(self)
            else:
                return visitor.visitChildren(self)


    class FactorParensContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)
        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorParens" ):
                listener.enterFactorParens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorParens" ):
                listener.exitFactorParens(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorParens" ):
                return visitor.visitFactorParens(self)
            else:
                return visitor.visitChildren(self)


    class FactorStringContext(FactorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.FactorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(EnglishLangParser.STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactorString" ):
                listener.enterFactorString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactorString" ):
                listener.exitFactorString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactorString" ):
                return visitor.visitFactorString(self)
            else:
                return visitor.visitChildren(self)



    def factor(self):

        localctx = EnglishLangParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_factor)
        try:
            self.state = 416
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                localctx = EnglishLangParser.UnaryPlusContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 403
                self.match(EnglishLangParser.PLUS)
                self.state = 404
                self.factor()
                pass

            elif la_ == 2:
                localctx = EnglishLangParser.UnaryMinusContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 405
                self.match(EnglishLangParser.MINUS)
                self.state = 406
                self.factor()
                pass

            elif la_ == 3:
                localctx = EnglishLangParser.FactorFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 407
                self.functionCall()
                pass

            elif la_ == 4:
                localctx = EnglishLangParser.FactorNumberContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 408
                self.match(EnglishLangParser.NUMBER)
                pass

            elif la_ == 5:
                localctx = EnglishLangParser.FactorIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 409
                self.match(EnglishLangParser.IDENTIFIER)
                pass

            elif la_ == 6:
                localctx = EnglishLangParser.FactorStringContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 410
                self.match(EnglishLangParser.STRING)
                pass

            elif la_ == 7:
                localctx = EnglishLangParser.FactorOperationContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 411
                self.operation()
                pass

            elif la_ == 8:
                localctx = EnglishLangParser.FactorParensContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 412
                self.match(EnglishLangParser.LPAREN)
                self.state = 413
                self.numExpression(0)
                self.state = 414
                self.match(EnglishLangParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def INCREMENT(self):
            return self.getToken(EnglishLangParser.INCREMENT, 0)

        def DECREMENT(self):
            return self.getToken(EnglishLangParser.DECREMENT, 0)

        def functionCall(self):
            return self.getTypedRuleContext(EnglishLangParser.FunctionCallContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_operation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperation" ):
                listener.enterOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperation" ):
                listener.exitOperation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperation" ):
                return visitor.visitOperation(self)
            else:
                return visitor.visitChildren(self)




    def operation(self):

        localctx = EnglishLangParser.OperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_operation)
        self._la = 0 # Token type
        try:
            self.state = 421
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 418
                self.match(EnglishLangParser.IDENTIFIER)
                self.state = 419
                _la = self._input.LA(1)
                if not(_la==36 or _la==37):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 420
                self.functionCall()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReassignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def SEMICOLON(self):
            return self.getToken(EnglishLangParser.SEMICOLON, 0)

        def SUBTRACT_FROM(self):
            return self.getToken(EnglishLangParser.SUBTRACT_FROM, 0)

        def numExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,0)


        def DIVIDE_FROM(self):
            return self.getToken(EnglishLangParser.DIVIDE_FROM, 0)

        def TIMES(self):
            return self.getToken(EnglishLangParser.TIMES, 0)

        def ADD_TO(self):
            return self.getToken(EnglishLangParser.ADD_TO, 0)

        def STRING(self):
            return self.getToken(EnglishLangParser.STRING, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_reassignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReassignment" ):
                listener.enterReassignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReassignment" ):
                listener.exitReassignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReassignment" ):
                return visitor.visitReassignment(self)
            else:
                return visitor.visitChildren(self)




    def reassignment(self):

        localctx = EnglishLangParser.ReassignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_reassignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 423
            self.match(EnglishLangParser.IDENTIFIER)
            self.state = 436
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [34]:
                self.state = 428
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
                if la_ == 1:
                    self.state = 424
                    self.match(EnglishLangParser.ADD_TO)
                    self.state = 425
                    self.match(EnglishLangParser.STRING)
                    pass

                elif la_ == 2:
                    self.state = 426
                    self.match(EnglishLangParser.ADD_TO)
                    self.state = 427
                    self.numExpression(0)
                    pass


                pass
            elif token in [35]:
                self.state = 430
                self.match(EnglishLangParser.SUBTRACT_FROM)
                self.state = 431
                self.numExpression(0)
                pass
            elif token in [39]:
                self.state = 432
                self.match(EnglishLangParser.DIVIDE_FROM)
                self.state = 433
                self.numExpression(0)
                pass
            elif token in [38]:
                self.state = 434
                self.match(EnglishLangParser.TIMES)
                self.state = 435
                self.numExpression(0)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 438
            self.match(EnglishLangParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolOrExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolOrExpressionContext,0)


        def getRuleIndex(self):
            return EnglishLangParser.RULE_boolExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolExpression" ):
                listener.enterBoolExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolExpression" ):
                listener.exitBoolExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolExpression" ):
                return visitor.visitBoolExpression(self)
            else:
                return visitor.visitChildren(self)




    def boolExpression(self):

        localctx = EnglishLangParser.BoolExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_boolExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 440
            self.boolOrExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolOrExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return EnglishLangParser.RULE_boolOrExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicOrContext(BoolOrExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolOrExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolAndExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolAndExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolAndExpressionContext,i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.OR)
            else:
                return self.getToken(EnglishLangParser.OR, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicOr" ):
                listener.enterLogicOr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicOr" ):
                listener.exitLogicOr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicOr" ):
                return visitor.visitLogicOr(self)
            else:
                return visitor.visitChildren(self)



    def boolOrExpression(self):

        localctx = EnglishLangParser.BoolOrExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_boolOrExpression)
        self._la = 0 # Token type
        try:
            localctx = EnglishLangParser.LogicOrContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 442
            self.boolAndExpression()
            self.state = 447
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==42:
                self.state = 443
                self.match(EnglishLangParser.OR)
                self.state = 444
                self.boolAndExpression()
                self.state = 449
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolAndExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return EnglishLangParser.RULE_boolAndExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicAndContext(BoolAndExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolAndExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolNotExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.BoolNotExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.BoolNotExpressionContext,i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(EnglishLangParser.AND)
            else:
                return self.getToken(EnglishLangParser.AND, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicAnd" ):
                listener.enterLogicAnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicAnd" ):
                listener.exitLogicAnd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicAnd" ):
                return visitor.visitLogicAnd(self)
            else:
                return visitor.visitChildren(self)



    def boolAndExpression(self):

        localctx = EnglishLangParser.BoolAndExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_boolAndExpression)
        self._la = 0 # Token type
        try:
            localctx = EnglishLangParser.LogicAndContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 450
            self.boolNotExpression()
            self.state = 455
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==41:
                self.state = 451
                self.match(EnglishLangParser.AND)
                self.state = 452
                self.boolNotExpression()
                self.state = 457
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolNotExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return EnglishLangParser.RULE_boolNotExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LogicPrimaryWrapContext(BoolNotExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolNotExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolPrimary(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolPrimaryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicPrimaryWrap" ):
                listener.enterLogicPrimaryWrap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicPrimaryWrap" ):
                listener.exitLogicPrimaryWrap(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicPrimaryWrap" ):
                return visitor.visitLogicPrimaryWrap(self)
            else:
                return visitor.visitChildren(self)


    class LogicNotContext(BoolNotExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolNotExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(EnglishLangParser.NOT, 0)
        def boolNotExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolNotExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicNot" ):
                listener.enterLogicNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicNot" ):
                listener.exitLogicNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicNot" ):
                return visitor.visitLogicNot(self)
            else:
                return visitor.visitChildren(self)



    def boolNotExpression(self):

        localctx = EnglishLangParser.BoolNotExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_boolNotExpression)
        try:
            self.state = 461
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [43]:
                localctx = EnglishLangParser.LogicNotContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 458
                self.match(EnglishLangParser.NOT)
                self.state = 459
                self.boolNotExpression()
                pass
            elif token in [6, 22, 24, 25, 51, 53, 55, 56, 63, 64, 70]:
                localctx = EnglishLangParser.LogicPrimaryWrapContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 460
                self.boolPrimary()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolPrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return EnglishLangParser.RULE_boolPrimary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class StringComparisonContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def stringExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.StringExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.StringExpressionContext,i)

        def EQUALS(self):
            return self.getToken(EnglishLangParser.EQUALS, 0)
        def NOT_EQUALS(self):
            return self.getToken(EnglishLangParser.NOT_EQUALS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringComparison" ):
                listener.enterStringComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringComparison" ):
                listener.exitStringComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringComparison" ):
                return visitor.visitStringComparison(self)
            else:
                return visitor.visitChildren(self)


    class FalseLiteralContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FALSE_VALUE(self):
            return self.getToken(EnglishLangParser.FALSE_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFalseLiteral" ):
                listener.enterFalseLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFalseLiteral" ):
                listener.exitFalseLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFalseLiteral" ):
                return visitor.visitFalseLiteral(self)
            else:
                return visitor.visitChildren(self)


    class NumComparisonContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def numExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.NumExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.NumExpressionContext,i)

        def comparisonOp(self):
            return self.getTypedRuleContext(EnglishLangParser.ComparisonOpContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumComparison" ):
                listener.enterNumComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumComparison" ):
                listener.exitNumComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumComparison" ):
                return visitor.visitNumComparison(self)
            else:
                return visitor.visitChildren(self)


    class LogicParenContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(EnglishLangParser.LPAREN, 0)
        def boolExpression(self):
            return self.getTypedRuleContext(EnglishLangParser.BoolExpressionContext,0)

        def RPAREN(self):
            return self.getToken(EnglishLangParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicParen" ):
                listener.enterLogicParen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicParen" ):
                listener.exitLogicParen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicParen" ):
                return visitor.visitLogicParen(self)
            else:
                return visitor.visitChildren(self)


    class TrueLiteralContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRUE_VALUE(self):
            return self.getToken(EnglishLangParser.TRUE_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrueLiteral" ):
                listener.enterTrueLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrueLiteral" ):
                listener.exitTrueLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrueLiteral" ):
                return visitor.visitTrueLiteral(self)
            else:
                return visitor.visitChildren(self)


    class LogicIdentifierContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENTIFIER(self):
            return self.getToken(EnglishLangParser.IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicIdentifier" ):
                listener.enterLogicIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicIdentifier" ):
                listener.exitLogicIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicIdentifier" ):
                return visitor.visitLogicIdentifier(self)
            else:
                return visitor.visitChildren(self)


    class MatrixComparisonContext(BoolPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a EnglishLangParser.BoolPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def matrixExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(EnglishLangParser.MatrixExpressionContext)
            else:
                return self.getTypedRuleContext(EnglishLangParser.MatrixExpressionContext,i)

        def EQUALS(self):
            return self.getToken(EnglishLangParser.EQUALS, 0)
        def NOT_EQUALS(self):
            return self.getToken(EnglishLangParser.NOT_EQUALS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatrixComparison" ):
                listener.enterMatrixComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatrixComparison" ):
                listener.exitMatrixComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatrixComparison" ):
                return visitor.visitMatrixComparison(self)
            else:
                return visitor.visitChildren(self)



    def boolPrimary(self):

        localctx = EnglishLangParser.BoolPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_boolPrimary)
        self._la = 0 # Token type
        try:
            self.state = 482
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                localctx = EnglishLangParser.NumComparisonContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 463
                self.numExpression(0)
                self.state = 464
                self.comparisonOp()
                self.state = 465
                self.numExpression(0)
                pass

            elif la_ == 2:
                localctx = EnglishLangParser.StringComparisonContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 467
                self.stringExpression()
                self.state = 468
                _la = self._input.LA(1)
                if not(_la==29 or _la==40):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 469
                self.stringExpression()
                pass

            elif la_ == 3:
                localctx = EnglishLangParser.MatrixComparisonContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 471
                self.matrixExpression()
                self.state = 472
                _la = self._input.LA(1)
                if not(_la==29 or _la==40):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 473
                self.matrixExpression()
                pass

            elif la_ == 4:
                localctx = EnglishLangParser.LogicParenContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 475
                self.match(EnglishLangParser.LPAREN)
                self.state = 476
                self.boolExpression()
                self.state = 477
                self.match(EnglishLangParser.RPAREN)
                pass

            elif la_ == 5:
                localctx = EnglishLangParser.TrueLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 479
                self.match(EnglishLangParser.TRUE_VALUE)
                pass

            elif la_ == 6:
                localctx = EnglishLangParser.FalseLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 480
                self.match(EnglishLangParser.FALSE_VALUE)
                pass

            elif la_ == 7:
                localctx = EnglishLangParser.LogicIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 481
                self.match(EnglishLangParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUALS(self):
            return self.getToken(EnglishLangParser.EQUALS, 0)

        def NOT_EQUALS(self):
            return self.getToken(EnglishLangParser.NOT_EQUALS, 0)

        def GREATER_THAN(self):
            return self.getToken(EnglishLangParser.GREATER_THAN, 0)

        def LESS_THAN(self):
            return self.getToken(EnglishLangParser.LESS_THAN, 0)

        def GREATER_EQUAL(self):
            return self.getToken(EnglishLangParser.GREATER_EQUAL, 0)

        def LESS_EQUAL(self):
            return self.getToken(EnglishLangParser.LESS_EQUAL, 0)

        def getRuleIndex(self):
            return EnglishLangParser.RULE_comparisonOp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOp" ):
                listener.enterComparisonOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOp" ):
                listener.exitComparisonOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOp" ):
                return visitor.visitComparisonOp(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOp(self):

        localctx = EnglishLangParser.ComparisonOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_comparisonOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 484
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1116154626048) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[29] = self.numExpression_sempred
        self._predicates[30] = self.term_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def numExpression_sempred(self, localctx:NumExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def term_sempred(self, localctx:TermContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 2)
         




